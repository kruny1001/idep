{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(RSQLite)\nlibrary(gplots)\nlibrary(ggplot2)\nlibrary(e1071) # computing kurtosis\nlibrary(reshape2) # for melt correlation matrix in heatmap\nlibrary(DT) # for renderDataTable\nlibrary(plotly) # for interactive heatmap\n# bioconductor packages\nlibrary(limma) # Differential expression\nlibrary(DESeq2) # count data analysis\nlibrary(edgeR) # count data D.E.\nlibrary(gage) # pathway analysis\nlibrary(PGSEA) # pathway\nlibrary(fgsea) # fast GSEA\nlibrary(ReactomePA) # pathway analysis\nlibrary(pathview)\nlibrary(PREDA)  # showing expression on genome\nlibrary(PREDAsampledata)\nlibrary(sfsmisc)\nlibrary(lokern)\nlibrary(multtest)\n\n# R packages needed\n# install.packages(c(\"shiny\",\"RSQLite\",\"gplots\",\"ggplot2\",\"e1071\",\"shinyAce\",\"shinyBS\",\"reshape2\",\"DT\",\"plotly\" ) )\n# bioconductor packages\n#source(\"https://bioconductor.org/biocLite.R\")\n#biocLite(c( \"limma\", \"DESeq2\",\"edgeR\",\"gage\", \"PGSEA\", \"fgsea\", \"ReactomePA\", \"pathview\" ))\n# annotation packages needed by pathview\n#biocLite( c( \"org.Ag.eg.db\",\"org.At.tair.db\",\"org.Bt.eg.db\",\"org.Ce.eg.db\",\"org.Cf.eg.db\",\"org.Dm.eg.db\",\"org.Dr.eg.db\",\"org.EcK12.eg.db\",\"org.EcSakai.eg.db\",\"org.Gg.eg.db\",\"org.Hs.eg.db\",\"org.Hs.ipi.db\",\"org.Mm.eg.db\",\"org.Mmu.eg.db\",\"org.Pf.plasmo.db\",\"org.Pt.eg.db\",\"org.Rn.eg.db\",\"org.Sc.sgd.db\",\"org.Sco.eg.db\",\"org.Ss.eg.db\",\"org.Tgondii.eg.db\",\"org.Xl.eg.db\")  )\n\npdf(NULL) # this prevents error Cannot open file 'Rplots.pdf'\nMin_overlap <- 2\nminSetSize = 3;\nmappingCoverage = 0.60 # 60% percent genes has to be mapped for confident mapping\nmappingEdge = 0.5  # Top species has 50% more genes mapped\nPvalGeneInfo = 0.05; minGenes = 10 # min number of genes for ploting\nkurtosis.log = 50  # log transform is enforced when kurtosis is big\nkurtosis.warning = 10 # log transformation recommnded\nminGenesEnrichment = 2 # perform GO or promoter analysis only if more than this many genes\nPREDA_Permutations =1000\n\n# this need to be removed. Also replace go to go for folder\n#setwd(\"C:/Users/Xijin.Ge/Google Drive/research/Shiny/RNAseqer\")\nsqlite  <- dbDriver(\"SQLite\")\nconvert <- dbConnect(sqlite,\"../go/convertIDs.db\")\nset.seed(2)\nmycolors = sort(rainbow(20))[c(1,20,10,11,2,19,3,12,4,13,5,14,6,15,7,16,8,17,9,18)] # 20 colors for kNN clusters\n\nhclust2 <- function(x, method=\"average\", ...)\n  hclust(x, method=method, ...)\n\n\ndist2 <- function(x, ...)\n  as.dist(1-cor(t(x), method=\"pearson\"))\n\nkeggSpeciesID = read.csv(\"KEGG_Species_ID.csv\")\n\n\ndetectGroups <- function (x){  # x are col names\n\ttem <- gsub(\"[0-9]*$\",\"\",x) # Remove all numbers from end\n\t#tem = gsub(\"_Rep|_rep|_REP\",\"\",tem)\n\ttem <- gsub(\"_Rep$\",\"\",tem); # remove \"_Rep\" from end\n\ttem <- gsub(\"_rep$\",\"\",tem); # remove \"_rep\" from end\n\ttem <- gsub(\"_REP$\",\"\",tem)  # remove \"_REP\" from end\n \treturn( tem )\n}\n\nmyheatmap <- function (x,n=-1) {\n  if(n == -1) n=dim(x)[1]\n  geneSD = apply(x,1,sd)\n  x = x[order(-geneSD),]\n  # this will cutoff very large values, which could skew the color\n  x=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n  cutoff = median(unlist(x)) + 3*sd (unlist(x))\n  x[x>cutoff] <- cutoff\n  cutoff = median(unlist(x)) - 3*sd (unlist(x))\n  x[x< cutoff] <- cutoff\n\n  hy <-  heatmap.2(x, distfun = dist2,hclustfun=hclust2,\n   col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n  #,Colv=FALSE,\n  ,key=F\n  ,margins = c(6, 8)\n  )\n}\n\nmyheatmap3 <- function (x,n=-1) {\nif( n > 0 && n< dim(x)[1]   )\n { geneSD = apply(x,1,sd)\n x = x[order(-geneSD),]\n# this will cutoff very large values, which could skew the color\n  x=as.matrix(x[1:n,])\n  }\n    x=as.matrix(x)-apply(x,1,mean)\ncutoff = median(unlist(x)) + 3*sd (unlist(x))\nx[x>cutoff] <- cutoff\ncutoff = median(unlist(x)) - 3*sd (unlist(x))\nx[x< cutoff] <- cutoff\ngroups = detectGroups(colnames(x))\ncolnames(x) = detectGroups(colnames(x))\nhy <-  heatmap.2(x, dendrogram =\"row\",distfun = dist2,hclustfun=hclust2,\n col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n#,Colv=FALSE,\n,labRow=\"\"\n#,labCol=\"\"\n,ColSideColors=mycolors[ groups]\n,key=F\n,margins = c(6, 20)\n)\nif(0) {\n\tlmat = rbind(c(5,4),c(0,1),c(3,2))\n\tlwid = c(1.5,6)\n\tlhei = c(1,.2,8)\n\nif( dim(x)[1]>100)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F\n\t,ColSideColors=mycolors[ groups]\n\t,labRow=\"\"\n\t,margins=c(6,8)\n\t,srtCol=45\n\t#,lmat = lmat, lwid = lwid, lhei = lhei\n\t)\n\n\tif( dim(x)[1] <=100)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F,\n\t#,labRow=labRow\n\t\t,ColSideColors=mycolors[ groups]\n\t,margins=c(6,8)\n\t,cexRow=1.5\n\t,srtCol=45\n\t#,lmat = lmat, lwid = lwid, lhei = lhei\n\t)\n  }\n\n}\n\n# randomly samples genes\nmyheatmap4 <- function (x,n=-1) {\n\nif( n > 0 && n< dim(x)[1]   )\n {\n  ix = sample(1:dim(x)[1], n)\n# this will cutoff very large values, which could skew the color\n  x=as.matrix(x[ix,])\n  }\n    x=as.matrix(x)-apply(x,1,mean)\ncutoff = median(unlist(x)) + 3*sd (unlist(x))\nx[x>cutoff] <- cutoff\ncutoff = median(unlist(x)) - 3*sd (unlist(x))\nx[x< cutoff] <- cutoff\ngroups = detectGroups(colnames(x))\ncolnames(x) = detectGroups(colnames(x))\nhy <-  heatmap.2(x, dendrogram =\"row\",distfun = dist2,hclustfun=hclust2,\n col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n,Colv=FALSE,\n,labRow=\"\"\n#,labCol=\"\"\n,ColSideColors=mycolors[ groups]\n,key=F\n,margins = c(6, 20)\n)\n\n}\n\n\nmyheatmap2 <- function (x,bar,n=-1 ) {\n# number of genes to show\nngenes = as.character( table(bar))\nif(length(bar) >n && n != -1) {ix = sort( sample(1:length(bar),n) ); bar = bar[ix]; x = x[ix,]  }\n\n# this will cutoff very large values, which could skew the color\nx=as.matrix(x)-apply(x,1,mean)\ncutoff = median(unlist(x)) + 3*sd (unlist(x))\nx[x>cutoff] <- cutoff\ncutoff = median(unlist(x)) - 3*sd (unlist(x))\nx[x< cutoff] <- cutoff\ncolnames(x)= detectGroups(colnames(x))\n heatmap.2(x,  Rowv =F,Colv=F, dendrogram =\"none\",\n col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n,key=F, labRow = F,\n,RowSideColors = mycolors[bar]\n,margins = c(8, 24)\n,srtCol=45\n)\n\nlegend.text = paste(\"Cluster \", toupper(letters)[unique(bar)], \" (N=\", ngenes,\")\", sep=\"\")\npar(lend = 1)           # square line ends for the color legend\nlegend(\"topright\",      # location of the legend on the heatmap plot\n    legend = legend.text, # category labels\n    col = mycolors,  # color key\n    lty= 1,             # line style\n    lwd = 10            # line width\n)\n\n}\n\ncleanGeneSet <- function (x){\n  # remove duplicate; upper case; remove special characters\n  x <- unique( toupper( gsub(\"\\n| \",\"\",x) ) )\n  x <- x[ which( nchar(x)>1) ]  # genes should have at least two characters\n  return(x)\n}\n# read GMT files, does NO cleaning. Assumes the GMT files are created with cleanGeneSet()\nreadGMT <- function (fileName){\n  x <- scan(fileName, what=\"\", sep=\"\\n\")\n  x <- strsplit(x, \"\\t\")\n  # Extract the first vector element and set it as the list element name\n  names(x) <- sapply(x, `[[`, 1)\n  x <- lapply(x, `[`, -c(1,2)) # 2nd element is comment, ignored\n  x = x[which(sapply(x,length) > 1)]  # gene sets smaller than 1 is ignored!!!\n  return(x)\n}\n\n# This functions cleans and converts to upper case\nreadGMTRobust <- function (file1) {   # size restriction\n\t# Read in the first file\n\tx <- scan(file1, what=\"\", sep=\"\\n\")\n\t# x <- gsub(\"\\t\\t.\",\"\",x)     # GMT files saved by Excel has a lot of empty cells \"\\t\\t\\t\\t\"   \"\\t.\" means one or more tab\n\tx <- gsub(\" \",\"\",x)  # remove white space\n\tx <- toupper(x)    # convert to upper case\n\n\t#----Process the first file\n\t# Separate elements by one or more whitespace\n\ty <- strsplit(x, \"\\t\")\n\t# Extract the first vector element and set it as the list element name\n\tnames(y) <- sapply(y, `[[`, 1)\n\t#names(y) <- sapply(y, function(x) x[[1]]) # same as above\n\t# Remove the first vector element from each list element\n\ty <- lapply(y, `[`, -c(1,2))\n\t#y <- lapply(y, function(x) x[-1]) # same as above\n\t# remove duplicated elements\n\tfor ( i in 1:length(y) )  y[[i]] <- cleanGeneSet(y[[i]])\n\t# check the distribution of the size of gene lists sapply(y, length) hold a vector of sizes\n\tif( max( sapply(y,length) ) <5) cat(\"Warning! Gene sets have very small number of genes!\\n Please double check format.\")\n\ty <- y[which(sapply(y,length) > 1)]  # gene sets smaller than 1 is ignored!!!\n\n\treturn(y)\n}\n\n# Given a gene set, finds significant overlaps with a gene set database  object\nfindOverlapGMT <- function ( query, geneSet, minFDR=.2 ,minSize=2,maxSize=10000 ){\n#geneSets <- readGMT(\"exampleData/MousePath_TF_gmt.gmt\")\n#query <-  geneSets[['TF_MM_FRIARD_C-REL']]\n#query <- query[1:60]\ntotal_elements = 30000\nMin_overlap <- 1\nmaxTerms =10 # max number of enriched terms\nnoSig <- as.data.frame(\"No significant enrichment found!\")\nquery <- cleanGeneSet(query)   # convert to upper case, unique()\n\nif(length(query) <=2) return(noSig)\nif(length(geneSet) <1) return(noSig)\n  geneSet <- geneSet[which(sapply(geneSet,length) > minSize)]  # gene sets smaller than 1 is ignored!!!\n  geneSet <- geneSet[which(sapply(geneSet,length) < maxSize)]  # gene sets smaller than 1 is ignored!!!\nresult <- unlist( lapply(geneSet, function(x) length( intersect (query, x) ) ) )\nresult <- cbind(unlist( lapply(geneSet, length) ), result )\nresult <- result[ which(result[,2]>Min_overlap), ,drop=F]\nif(dim(result)[1] == 0) return( noSig)\nxx <- result[,2]\nmm <- length(query)\nnn <- total_elements - mm\nkk <- result[,1]\nPval_enrich=phyper(xx-1,mm,nn,kk, lower.tail=FALSE );\nFDR <- p.adjust(Pval_enrich,method=\"fdr\",n=length(geneSet) )\nresult <- as.data.frame(cbind(FDR,result))\nresult <- result[,c(1,3,2)]\nresult$pathway = rownames(result)\nresult$Genes = \"\"  # place holder just\ncolnames(result)= c(\"Corrected P value (FDR)\", \"Genes in list\", \"Total genes in category\",\"Functional Category\",\"Genes\"  )\nresult <- result[ which( result[,1] < minFDR),,drop=F]\nif( dim( result)[1] == 0) return(noSig)\nif(min(FDR) > minFDR) return(noSig)\nresult <- result[order(result[,1] ),]\nif(dim(result)[1] > maxTerms ) result <- result[1:maxTerms,]\n\nreturn( result)\n}\n\ngeneChange <- function(x){\n\t  n = length(x)\n\t  if( n<4) return( max(x)-min(x)  ) else\n\t  return(sort(x)[n-1] - sort(x)[2]   )\n\t}\nmyPGSEA  <- function (exprs, cl, range = c(25, 500), ref = NULL, center = TRUE,\n    p.value = 0.005, weighted = TRUE, nPermutation=100, enforceRange = TRUE, ...)\n{\n    if (is(exprs, \"ExpressionSet\"))\n        exprs <- exprs(exprs)\n    if (!is.list(cl))\n        stop(\"cl need to be a list\")\n    if (!is.null(ref)) {\n        if (!is.numeric(ref))\n            stop(\"column index's required\")\n    }\n    if (!is.null(ref)) {\n        if (options()$verbose)\n            cat(\"Creating ratios...\", \"\\n\")\n        ref_mean <- apply(exprs[, ref], 1, mean, na.rm = TRUE)\n        exprs <- sweep(exprs, 1, ref_mean, \"-\")\n    }\n    if (center)\n        exprs <- scale(exprs, scale = FALSE)         # column centering is done\n    results <- matrix(NA, length(cl), ncol(exprs))\n    rownames(results) <- names(cl)\n    colnames(results) <- colnames(exprs)\n    mode(results) <- \"numeric\"\n\tSetsize = c(rep(0,length(cl)))     # gene set size vector\n\tmean2 = c(rep(0,length(cl)))     # mean of the range of means\n\tmeanSD = c(rep(0,length(cl)))     # SD of the range of means\n    if (is.logical(p.value))\n        { p.results <- results; mean.results <- results;}\n    for (i in 1:length(cl)) {              # for each gene list\n\t\t#cat(\"\\nProcessing gene set\",i);\n        if (class(cl[[i]]) == \"smc\") {\n            clids <- cl[[i]]@ids\n        }\n        else if (class(cl[[i]]) %in% c(\"GeneColorSet\", \"GeneSet\")) {\n            clids <- cl[[i]]@geneIds\n        }\n        else {\n            clids <- cl[[i]]\n        }\n        if (options()$verbose)\n            cat(\"Testing region \", i, \"\\n\")\n        ix <- match(clids, rownames(exprs))\n        ix <- unique(ix[!is.na(ix)])\n        present <- sum(!is.na(ix))\n\t\tSetsize[i] <- present\n        if (present < range[1]) {\n            if (options()$verbose)\n                cat(\"Skipping region \", i, \" because too small-\",\n                  present, \",\\n\")\n            next\n        }\n        if (present > range[2]) {\n            if (options()$verbose)\n                cat(\"Skipping region \", i, \" because too large-\",\n                  present, \"\\n\")\n            next\n        }\n        texprs <- exprs[ix, ]           # expression matrix for genes in gene set\n        if (any(is.na(texprs)))\n            cat(\"Warning - 'NA' values within expression data, enrichment scores are estimates only.\\n\")\n        if (!is.matrix(texprs))\n            texprs <- as.matrix(texprs)\n\n        stat <- try(apply(texprs, 2, t.test, ...))\n\t\tmeans <- try(apply(texprs, 2, mean,trim=0.1))   # trim mean\n\t\tps <- unlist(lapply(stat, function(x) x$p.value))\n        stat <- unlist(lapply(stat, function(x) x$statistic))\n        p.results[i, ] <- ps\n\t\tmean.results[i,] <- means\n        results[i, ] <- as.numeric(stat)\n\n\t\t# permutation of gene sets of the same size\n\t\tif(nPermutation > 2 )  { # no permutation if <=2\n\t\t\tmeansRanges = c(0, rep(nPermutation))\n\t\t\tfor( k in 1:nPermutation ) {\n\t\t\t\tix <- sample.int( dim(exprs)[1], length(ix) )\n\t\t\t\ttexprs <- exprs[ix, ]\n\t\t\t\tmeans <- try(apply(texprs, 2, mean,trim=0.1))   # trim mean\n\t\t\t\tmeansRanges[k] = dynamicRange(means)\n\t\t\t}\n\t\t\tmean2[i] = mean(meansRanges)\n\t\t\tmeanSD[i]= sd(meansRanges,na.rm=TRUE)   # NA are removed before calculating standard deviation\n\t\t}\n    }\n    return(list(results = results, p.results = p.results, means = mean.results, size=Setsize, mean2=mean2, meanSD=meanSD))\n}\n\ndynamicRange <- function( x ) {\ny = sort(x)\n   if(length(x)>=4)  k =2 else k =1;\n   return( y[length(x)-k+1] - y[k])\n}\n\n# Create a list of GMT files in /gmt sub folder\ngmtFiles = list.files(path = \"../go/pathwayDB\",pattern=\".*\\\\.db\")\ngmtFiles = paste(\"../go/pathwayDB/\",gmtFiles,sep=\"\")\n\ngeneInfoFiles = list.files(path = \"../go/geneInfo\",pattern=\".*GeneInfo\\\\.csv\")\ngeneInfoFiles = paste(\"../go/geneInfo/\",geneInfoFiles,sep=\"\")\n\nmotifFiles = list.files(path = \"../go/motif\",pattern=\".*\\\\.db\")\nmotifFiles = paste(\"../go/motif/\",motifFiles,sep=\"\")\n\n# Create a list for Select Input options\norgInfo <- dbGetQuery(convert, paste(\"select distinct * from orgInfo \" ))\norgInfo <- orgInfo[order(orgInfo$name),]\nspeciesChoice <- setNames(as.list( orgInfo$id ), orgInfo$name2 )\n# add a defult element to list    # new element name       value\nspeciesChoice <- append( setNames( \"NEW\",\"**NEW SPECIES**\"), speciesChoice  )\nspeciesChoice <- append( setNames( \"BestMatch\",\"Best matching species\"), speciesChoice  )\n\n# move one element to the 2nd place\nmove2 <- function(i) c(speciesChoice[1:2],speciesChoice[i],speciesChoice[-c(1,i)])\ni= grep(\"Glycine max\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Zea mays\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Arabidopsis thaliana\",names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Saccharomyces cerevisiae\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Caenorhabditis elegans\",names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Danio rerio\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Bos taurus\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Rattus norvegicus\" ,names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Mus musculus\",names(speciesChoice)); speciesChoice <- move2(i)\ni= grep(\"Homo sapiens\",names(speciesChoice)); speciesChoice <- move2(i)\n\nGO_levels = dbGetQuery(convert, \"select distinct id,level from GO\n                                WHERE GO = 'biological_process'\"  )\nlevel2Terms = GO_levels[which(GO_levels$level %in% c(2,3))  ,1]  # level 2 and 3\n\nidIndex <- dbGetQuery(convert, paste(\"select distinct * from idIndex \" ))\n\nquotes <- dbGetQuery(convert, \" select * from quotes\")\nquotes = paste0(\"\\\"\",quotes$quotes,\"\\\"\", \" -- \",quotes$author,\".       \")\n\n# This function convert gene set names\n# x=\"GOBP_mmu_mgi_GO:0000183_chromatin_silencing_at_rDNA\"\n# chromatin silencing at rDNA\nproper=function(x) paste0(toupper(substr(x, 1, 1)), substring(x, 2))\nextract1 <- function (x) {\n  words <- unlist ( strsplit(x,\"_\"))\n  if(length( words )  <=4 ) return(gsub(\"_\",\" \",x)) else {\n  words <- words[-c(1:4)]\n  return( proper(paste(words,collapse = \" \") ) )}\n}\n#find idType based on index\nfindIDtypeById <- function(x){ # find\n  return( idIndex$idType[ as.numeric(x)] )\n}\nfindSpeciesById <- function (speciesID){ # find species name use id\n  return( orgInfo[which(orgInfo$id == speciesID),]  )\n}\n# just return name\nfindSpeciesByIdName <- function (speciesID){ # find species name use id\n  return( orgInfo[which(orgInfo$id == speciesID),3]  )\n}\n\n# convert sorted species:idType combs into a list for repopulate species choice\nmatchedSpeciesInfo <- function (x) {\n  a<- c()\n  for( i in 1:length(x)) {\n    a = c(a,paste( gsub(\"genes.*\",\"\",findSpeciesByIdName( as.numeric(gsub(\" .*\",\"\",names(x[i])) ))), \" (\",\n                   x[i],\" mapped from \",findIDtypeById( gsub(\".* \",\"\",names(x[i]) ) ),\")\",sep=\"\")\n    ) }\n  return(a )\n}\n\n# convert gene IDs to ensembl gene ids and find species\nconvertID <- function (query,selectOrg, selectGO) {\n  querySet <- cleanGeneSet( unlist( strsplit( toupper(query),'\\t| |\\n|\\\\,' )  ) )\n  result <- dbGetQuery( convert,\n                        paste( \" select distinct id,ens,species from mapping where id IN ('\", paste(querySet,collapse=\"', '\"),   \"')\",sep=\"\") )\n  if( dim(result)[1] == 0  ) return(NULL)\n  if(selectOrg == speciesChoice[[1]]) {\n    comb = paste( result$species,result$idType)\n    sortedCounts = sort( table(comb ),decreasing=T)\n    recognized =names(sortedCounts[1]  )\n    result <- result[which(comb == recognized )  , ]\n\n\tspeciesMatched=sortedCounts\n    names(speciesMatched )= sapply(as.numeric(gsub(\" .*\",\"\",names(sortedCounts) ) ), findSpeciesByIdName  )\n    speciesMatched <- as.data.frame( speciesMatched )\n\tif(length(sortedCounts) == 1) { # if only  one species matched\n\t  speciesMatched[1,1] <-paste( rownames(speciesMatched), \"(\",speciesMatched[1,1],\")\",sep=\"\")\n\t } else {# if more than one species matched\n\t\tspeciesMatched[,1] <- as.character(speciesMatched[,1])\n\t\tspeciesMatched[,1] <- paste( speciesMatched[,1],\" (\",speciesMatched[,2], \")\", sep=\"\")\n\t\tspeciesMatched[1,1] <- paste( speciesMatched[1,1],\"   ***Used in mapping***  To change, select from above and resubmit query.\")\n\t\tspeciesMatched <- as.data.frame(speciesMatched[,1])\n\t}\n\n  } else { # if species is selected\n    result <- result[which(result$species == selectOrg ) ,]\n    if( dim(result)[1] == 0  ) return(NULL) #stop(\"ID not recognized!\")\n    speciesMatched <- as.data.frame(paste(\"Using selected species \", findSpeciesByIdName(selectOrg) )  )\n  }\n  result <- result[which(!duplicated(result[,2]) ),] # remove duplicates in ensembl_gene_id\n  colnames(speciesMatched) = c(\"Matched Species (genes)\" )\n  conversionTable <- result[,1:2]; colnames(conversionTable) = c(\"User_input\",\"ensembl_gene_id\")\n  conversionTable$Species = sapply(result[,3], findSpeciesByIdName )\n\n  if(0){\n  # generate a list of gene set categories\n  ix = grep(findSpeciesById(result$species[1])[1,1],gmtFiles)\n\n  if (length(ix) == 0 ) {categoryChoices = NULL}\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], gmtFiles )\n\tif (length(ix) == 0 ) {categoryChoices = NULL}\n\ttotalGenes <- orgInfo[which(orgInfo$id == as.numeric(selectOrg)),7]\n  }\n  pathway <- dbConnect(sqlite,gmtFiles[ix])\n\n  # Generate a list of geneset categories such as \"GOBP\", \"KEGG\" from file\n  geneSetCategory <-  dbGetQuery(pathway, \"select distinct * from categories \" )\n  geneSetCategory  <- geneSetCategory[,1]\n  categoryChoices <- setNames(as.list( geneSetCategory ), geneSetCategory )\n  categoryChoices <- append( setNames( \"All\",\"All available gene sets\"), categoryChoices  )\n  #change GOBO to the full description for display\n  names(categoryChoices)[ match(\"GOBP\",categoryChoices)  ] <- \"GO Biological Process\"\n  names(categoryChoices)[ match(\"GOCC\",categoryChoices)  ] <- \"GO Cellular Component\"\n  names(categoryChoices)[ match(\"GOMF\",categoryChoices)  ] <- \"GO Molecular Function\"\n\n  dbDisconnect(pathway)\n\n  } #if (0)\n  return(list(originalIDs = querySet,IDs=unique( result[,2]),\n              species = findSpeciesById(result$species[1]),\n              #idType = findIDtypeById(result$idType[1] ),\n              speciesMatched = speciesMatched,\n\t\t\t  conversionTable = conversionTable\n\t\t\t  ) )\n}\n\nconvertEnsembl2Entrez <- function (query,Species) {\n  querySet <- cleanGeneSet( unlist( strsplit( toupper(names( query)),'\\t| |\\n|\\\\,' )  ) )\n  speciesID <- orgInfo$id[ which(orgInfo$ensembl_dataset == Species)]  # note uses species Identifying\n  # idType 6 for entrez gene ID\n  result <- dbGetQuery( convert,\n                       paste( \" select  id,ens,species from mapping where ens IN ('\", paste(querySet,collapse=\"', '\"),\n                \t\t\t\"') AND  idType ='6'\",sep=\"\") )\t# slow\n\n  if( dim(result)[1] == 0  ) return(NULL)\n  result <- subset(result, species==speciesID, select = -species)\n\n  ix = match(result$ens,names(query)  )\n\n  tem <- query[ix];  names(tem) = result$id\n  return(tem)\n\n}\n\nconvertEnsembl2KEGG <- function (query,Species) {  # not working\n  querySet <- cleanGeneSet( unlist( strsplit( toupper(names( query)),'\\t| |\\n|\\\\,' )  ) )\n  speciesID <- orgInfo$id[ which(orgInfo$ensembl_dataset == Species)]  # note uses species Identifying\n  # idType 6 for entrez gene ID\n  result <- dbGetQuery( convert,\n                       paste( \" select  id,ens,species from mapping where ens IN ('\", paste(querySet,collapse=\"', '\"),\n                \t\t\t\"') AND  idType ='107'\",sep=\"\") )\t# slow\n\n  if( dim(result)[1] == 0  ) return(NULL)\n  result <- subset(result, species==speciesID, select = -species)\n\n  ix = match(result$ens,names(query)  )\n\n  tem <- query[ix];  names(tem) = result$id\n  return(tem)\n}\n\ngeneInfo <- function (converted,selectOrg){\n  # query = scan(\"query_temp.txt\",what=\"\"); selectOrg =\"BestMatch\";\n   # query = scan(\"zebrafish_test.gmt\", what=\"\" ); selectOrg =\"BestMatch\";\n  # query = scan(\"Celegans_test.gmt\", what=\"\" ); selectOrg =\"BestMatch\";\n  # query = scan(\"test_query_mouse_symbol.txt\", what=\"\" ); selectOrg =\"BestMatch\";\n  #  query = scan(\"soy_test.txt\", what=\"\" );selectOrg =\"BestMatch\";\n  # querySet <- cleanGeneSet( unlist( strsplit( toupper(query),'\\t| |\\n|\\\\,')))\n  # converted = convertID( querySet,selectOrg)\n  if(is.null(converted) ) return(as.data.frame(\"ID not recognized!\") ) # no ID\n  querySet <- converted$IDs\n  if(length(querySet) == 0) return(as.data.frame(\"ID not recognized!\") )\n  ix = grep(converted$species[1,1],geneInfoFiles)\n  if (length(ix) == 0 ) {return(as.data.frame(\"No matching gene info file found\") )} else {\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], geneInfoFiles )\n  }\n  if(length(ix) == 1)  # if only one file           #WBGene0000001 some ensembl gene ids in lower case\n  { x = read.csv(as.character(geneInfoFiles[ix]) ); x[,1]= toupper(x[,1]) } else # read in the chosen file\n  { return(as.data.frame(\"Multiple geneInfo file found!\") )   }\n  Set = match(x$ensembl_gene_id, querySet)\n  Set[which(is.na(Set))]=\"Genome\"\n  Set[which(Set!=\"Genome\")] =\"List\"\n  # x = cbind(x,Set) } # just for debuging\n  return( cbind(x,Set) )}\n }\n\n # Main function. Find a query set of genes enriched with functional category\nFindOverlap <- function (converted,gInfo, GO,selectOrg,minFDR) {\n  maxTerms =10 # max number of enriched terms\n  idNotRecognized = as.data.frame(\"ID not recognized!\")\n\n  if(is.null(converted) ) return(idNotRecognized) # no ID\n\n  # only coding\n  gInfo <- gInfo[which( gInfo$gene_biotype == \"protein_coding\"),]\n  querySet <- intersect( converted$IDs, gInfo[,1]);\n\n  if(length(querySet) == 0) return(idNotRecognized )\n\n  ix = grep(converted$species[1,1],gmtFiles)\n  totalGenes <- converted$species[1,7]\n\n  if (length(ix) == 0 ) {return(idNotRecognized )}\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], gmtFiles )\n\tif (length(ix) == 0 ) {return(idNotRecognized )}\n\ttotalGenes <- orgInfo[which(orgInfo$id == as.numeric(selectOrg)),7]\n  }\n  pathway <- dbConnect(sqlite,gmtFiles[ix])\n\n\n  sqlQuery = paste( \" select distinct gene,pathwayID from pathway where gene IN ('\", paste(querySet,collapse=\"', '\"),\"')\" ,sep=\"\")\n\n  #cat(paste0(\"HH\",GO,\"HH\") )\n\n  if( GO != \"All\") sqlQuery = paste0(sqlQuery, \" AND category ='\",GO,\"'\")\n  result <- dbGetQuery( pathway, sqlQuery  )\n  if( dim(result)[1] ==0) {return(as.data.frame(\"No matching species or gene ID file!\" )) }\n\n   # given a pathway id, it finds the overlapped genes, symbol preferred\n  sharedGenesPrefered <- function(pathwayID) {\n    tem <- result[which(result[,2]== pathwayID ),1]\n\tix = match(tem, converted$conversionTable$ensembl_gene_id) # convert back to original\n\ttem2 <- unique( converted$conversionTable$User_input[ix] )\n    if(length(unique(gInfo$symbol) )/dim(gInfo)[1] >.7  ) # if 70% genes has symbol in geneInfo\n\t{ ix = match(tem, gInfo$ensembl_gene_id);\n\t  tem2 <- unique( gInfo$symbol[ix] )      }\n  return( paste( tem2 ,collapse=\" \",sep=\"\") )}\n\n  x0 = table(result$pathwayID)\n  x0 = as.data.frame( x0[which(x0>=Min_overlap)] )# remove low overlaps\n  if(dim(x0)[1] <= 5 ) return(idNotRecognized) # no data\n  colnames(x0)=c(\"pathwayID\",\"overlap\")\n  pathwayInfo <- dbGetQuery( pathway, paste( \" select distinct id,n,Description from pathwayInfo where id IN ('\",\n\t\t\t\t\t\tpaste(x0$pathwayID,collapse=\"', '\"),   \"') \",sep=\"\") )\n\n  x = merge(x0,pathwayInfo, by.x='pathwayID', by.y='id')\n\n  x$Pval=phyper(x$overlap-1,length(querySet),totalGenes - length(querySet),as.numeric(x$n), lower.tail=FALSE );\n  x$FDR = p.adjust(x$Pval,method=\"fdr\")\n  x <- x[ order( x$FDR)  ,]  # sort according to FDR\n\n\n  if(min(x$FDR) > minFDR) x=as.data.frame(\"No significant enrichment found!\") else {\n  x <- x[which(x$FDR < minFDR),]\n  if(dim(x)[1] > maxTerms ) x = x[1:maxTerms,]\n  x= cbind(x,sapply( x$pathwayID, sharedGenesPrefered ) )\n  colnames(x)[7]= \"Genes\"\n  x <- subset(x,select = c(FDR,overlap,n,description,Genes) )\n  colnames(x) = c(\"Corrected P value (FDR)\", \"Genes in list\", \"Total genes in category\",\"Functional Category\",\"Genes\"  )\n  }\n\n dbDisconnect(pathway)\n return(x )\n}\n                                     #, categoryChoices = categoryChoices\n #Given a KEGG pathway description, found pathway ids\nkeggPathwayID <- function (pathwayDescription, Species, GO,selectOrg) {\n  ix = grep(Species,gmtFiles)\n\n  if (length(ix) == 0 ) {return(NULL)}\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], gmtFiles )\n\tif (length(ix) == 0 ) {return(NULL )}\n\ttotalGenes <- orgInfo[which(orgInfo$id == as.numeric(selectOrg)),7]\n  }\n  pathway <- dbConnect(sqlite,gmtFiles[ix])\n\n  pathwayInfo <- dbGetQuery( pathway, paste( \" select * from pathwayInfo where description =  '\",\n\t\t\t\t\t\tpathwayDescription,   \"' AND name LIKE '\",GO,\"%'\",sep=\"\") )\n  dbDisconnect(pathway);\n  if(dim(pathwayInfo)[1] != 1 ) {return(NULL) }\n  tem = gsub(\".*:\",\"\",pathwayInfo[1,2])\n  return( gsub(\"_.*\",\"\",tem) )\n  }\n\n\ngmtCategory <- function (converted, convertedData, selectOrg,gmtFile) {\n  if(selectOrg == \"NEW\" && !is.null(gmtFile) )\n     return( list(Custom_GeneSet =\"Custom\" ) )\n  idNotRecognized = as.data.frame(\"ID not recognized!\")\n  if(is.null(converted) ) return(idNotRecognized) # no ID\n  querySet <- rownames(convertedData)\n  if(length(querySet) == 0) return(idNotRecognized )\n  ix = grep(converted$species[1,1],gmtFiles)\n  if (length(ix) == 0 ) {return(idNotRecognized )}\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], gmtFiles )\n\tif (length(ix) == 0 ) {return(idNotRecognized )}\n  }\n  pathway <- dbConnect(sqlite,gmtFiles[ix])\n cat(paste(\"selectOrg:\",selectOrg) )\n  # Generate a list of geneset categories such as \"GOBP\", \"KEGG\" from file\n  geneSetCategory <-  dbGetQuery(pathway, \"select distinct * from categories \" )\n  geneSetCategory  <- geneSetCategory[,1]\n  categoryChoices <- setNames(as.list( geneSetCategory ), geneSetCategory )\n  categoryChoices <- append( setNames( \"All\",\"All available gene sets\"), categoryChoices  )\n  #change GOBO to the full description for display\n  names(categoryChoices)[ match(\"GOBP\",categoryChoices)  ] <- \"GO Biological Process\"\n  names(categoryChoices)[ match(\"GOCC\",categoryChoices)  ] <- \"GO Cellular Component\"\n  names(categoryChoices)[ match(\"GOMF\",categoryChoices)  ] <- \"GO Molecular Function\"\n\n  dbDisconnect(pathway)\n return(categoryChoices )\n}\n\n# Main function. Find a query set of genes enriched with functional category\nreadGeneSets <- function (converted, convertedData, GO,selectOrg, myrange) {\n  idNotRecognized = as.data.frame(\"ID not recognized!\")\n  if(is.null(converted) ) return(idNotRecognized) # no ID\n  querySet <- rownames(convertedData)\n  if(length(querySet) == 0) return(idNotRecognized )\n  ix = grep(converted$species[1,1],gmtFiles)\n  if (length(ix) == 0 ) {return(idNotRecognized )}\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], gmtFiles )\n\tif (length(ix) == 0 ) {return(idNotRecognized )}\n  }\n  pathway <- dbConnect(sqlite,gmtFiles[ix])\n\n  if(is.null(GO) ) GO <- \"GOBP\"   # initial value not properly set; enforcing\n\n # get Gene sets\n  querySet = rownames(convertedData)\n  sqlQuery = paste( \" select distinct gene,pathwayID from pathway where gene IN ('\", paste(querySet,collapse=\"', '\"),\"')\" ,sep=\"\")\n # cat(paste0(\"\\n\\nhere:\",GO,\"There\"))\n\n  if( GO != \"All\") sqlQuery = paste0(sqlQuery, \" AND category ='\",GO,\"'\")\n  result <- dbGetQuery( pathway, sqlQuery  )\n  if( dim(result)[1] ==0) {return(list( x=as.data.frame(\"No matching species or gene ID file!\" )) )}\n  # list pathways and frequency of genes\n  pathwayIDs = aggregate( result$pathwayID, by   = list(unique.values = result$pathwayID), FUN = length)\n  pathwayIDs = pathwayIDs[which(pathwayIDs[,2]>= myrange[1] ),]\n  pathwayIDs = pathwayIDs[which( pathwayIDs[,2] <= myrange[2] ),]\n  if(dim(pathwayIDs)[1] ==0 ) geneSets = NULL;\n\n   # convert pathways into lists like those generated by readGMT\n   geneSets = lapply(pathwayIDs[,1], function(x)  result[which(result$pathwayID == x ),1]     )\n   pathwayInfo <- dbGetQuery( pathway, paste( \" select distinct id,Description from pathwayInfo where id IN ('\",\n\t\t\t\t\t\tpaste(pathwayIDs[,1],collapse=\"', '\"),   \"') \",sep=\"\") )\n   ix = match( pathwayIDs[,1], pathwayInfo[,1])\n   names(geneSets) <- pathwayInfo[ix,2]\n   #geneSets <- geneSets[ -which(duplicated(names(geneSets) ))] # remove geneSets with the same name\n  dbDisconnect(pathway)\n return( geneSets )\n}\n\nPGSEApathway <- function (converted,convertedData, selectOrg,GO,gmt, myrange,Pval_pathway,top){\n  \tsubtype = detectGroups(colnames(convertedData))\n\tPvalue = 0.01  # cut off to report in PGSEA. Otherwise NA\n\t#Pval_pathway = 0.2   # cut off for P value of ANOVA test  to writ to file\n\t# top = 30   # number of pathways to show\n\tif(length(gmt) ==0 ) return( list(pg3 = NULL, best = best ) )\n    # centering by mean\n\t#pg = myPGSEA (convertedData - rowMeans(convertedData),\n\t #            cl=gmt,range=myrange,p.value=TRUE, weighted=FALSE,nPermutation=100)\n\tpg = PGSEA (convertedData - rowMeans(convertedData),cl=gmt,range=myrange,p.value=TRUE, weighted=FALSE)\n\n\tpg2 = pg$results;\n\tpg2 = pg2[rowSums(is.na(pg2))<ncol(pg2) ,]  # remove se/wrts with all missing(non-signficant)\n\tif (dim(pg2)[1] < 2 ) return()\n\tbest = max(abs(pg2))\n\n\tif(length(subtype) < 4 || length(unique(subtype)) <2 ||length(unique(subtype)) == dim(convertedData)[2] ) {\n\t pg2 = pg2[order(-apply(pg2,1,sd)     )   ,]\n\t return( list(pg3 = pg2[1:top,], best = best ) )\n\t}\n\n\tcat(\"\\nComputing P values using ANOVA\\n\");\n\tpathPvalue <- function ( k){\n\t return( summary(aov(pg2[k,]~subtype) )[[1]][[\"Pr(>F)\"]][1] )\n\t}\n\tPvalues = sapply(1:dim(pg2)[1], pathPvalue)\n\tPvalues = p.adjust(Pvalues, \"fdr\")\n\n\t#if(min(Pvalues) > Pval_pathway ) return( list(pg3 = NULL, best = best ) )  else {\n    if(sort(Pvalues)[2] > Pval_pathway ) return( list(pg3 = NULL, best = best ) )  else {\n\n\tNsigT = rowSums(pg$p.results<Pvalue)\n\n\tresult=cbind( as.matrix(Pvalues),NsigT,pg2);\n\tresult = result[ order(result[,1])   ,]\n\n\tresult = result[which(result[,1] < Pval_pathway),,drop=F]\n\t#result = result[which(result[,2] >2)    ,]\n\tpg2 = result[,-2]\n\n\t# when there is only 1 left in the matrix pg2 becomes a vector\n\tif(sum( Pvalues<Pval_pathway) == 1) { pg3 = t( as.matrix(pg2));pg3 = rbind(pg3,pg3);} else\n\t{ if(dim(pg2)[1] > top ) {  pg3 = pg2[1:top,]; } else {  pg3 = pg2;  } }\n\n\trownames(pg3) = sapply(rownames(pg3) , extract1)\n\ta=sprintf(\"%-1.0e\",pg3[,1])\n\trownames(pg3) = paste(a,rownames(pg3),sep=\" \")\n\tpg3 =pg3[,-1]\n\n\tpg3 <- pg3[order( -apply(pg3,1,sd)    ),] # sort by SD\n\n    return( list(pg3 = pg3, best = best ) )\n    }\n }\n\nDEG.limma <- function (x, maxP_limma=.1, minFC_limma=2, rawCounts,countsDEGMethods,priorCounts, dataFormat){\n topGenes = list();  limmaTrend = FALSE\n if( dataFormat == 2) {   # if normalized data\n\teset = new(\"ExpressionSet\", exprs=as.matrix(x)) } else { # counts data\n\t\tif (countsDEGMethods == 1 ) { # limma-trend method selected for counts data\n\t\t\tdge <- DGEList(counts=rawCounts);\n\t\t\tdge <- calcNormFactors(dge)\n\t\t\teset <- cpm(dge, log=TRUE, prior.count=priorCounts)\n\t\t\tlimmaTrend = TRUE\n\t\t}\n }\n\n groups = colnames(x)\n groups = detectGroups( groups)\n g =  unique(groups)\n\n # check for replicates, removes samples without replicates\n reps = as.matrix(table(groups)) # number of replicates per biological sample\n if ( sum( reps[,1] >= 2) <2 ) # if less than 2 samples with replicates\n return( list(results= NULL, comparisons = NULL, Exp.type=\"Failed to parse sample names to define groups.\n       Cannot perform DEGs and pathway analysis. Please double check column names! Use WT_Rep1, WT_Rep2 etc. \", topGenes=NULL))\n # remove samples without replicates\n g <- rownames(reps)[which(reps[,1] >1)]\n ix <- which( groups %in% g)\n groups <- groups[ix]\n x<- x[,ix]; rawCounts <- rawCounts[,ix]\n\n\n if(length(g) ==2 ) {\n  g= unique(groups)\n comparisons <-  paste(g[2],\"-\",g[1],sep=\"\")\n design <- model.matrix(~0+groups)\n colnames(design) <- g\n\n if( !is.null(rawCounts) && countsDEGMethods == 2) {  # voom\n     v <- voom(rawCounts, design); fit <- lmFit(v, design) } else\n\tfit <- lmFit(eset, design)      # regular limma\n\ncont.matrix <- makeContrasts(contrasts=comparisons, levels=design)\nfit2 <- contrasts.fit(fit, cont.matrix)\nfit2 <- eBayes(fit2, trend=limmaTrend)\n\n # calls differential gene expression 1 for up, -1 for down\n results <- decideTests(fit2, p.value=maxP_limma, lfc=log2(minFC_limma) )\n #vennDiagram(results,circle.col=rainbow(5))\n topGenes1 =topTable(fit2, number = 1e12,sort.by=\"M\" )\n if (dim(topGenes1)[1] != 0) {\n topGenes1 = topGenes1[,c('logFC','adj.P.Val')]\n # topGenes1[,1] <-  -1* topGenes1[,1] # reverse direction\n topGenes[[1]] <- topGenes1 }\n  # log fold change is actually substract of means. So if the data is natral log transformed, it shoudl be natral log.\n Exp.type = \"2 biological samples.\"\n }\n\n  if(length(g) > 2 ) {\n design <- model.matrix(~ 0+factor(groups))\n colnames(design) <- gsub(\".*)\",\"\",colnames(design))\n\n if( !is.null(rawCounts) && countsDEGMethods == 2) {  # voom\n     v <- voom(rawCounts, design); fit <- lmFit(v, design) } else\n\t\tfit <- lmFit(eset, design)\n\n fit <- eBayes(fit, trend=limmaTrend)\n\n comparisons = \"\"\n  for( i in 1:(length(g)-1) )\n    for (j in (i+1):length(g))\n\t comparisons = c(comparisons,paste(g[j],\"-\",g[i],sep=\"\" ) )\n  comparisons <- comparisons[-1]\n\ncontrast1 <- makeContrasts(contrasts=comparisons[1], levels=design)\nfor( kk in 2:length(comparisons) )\n     contrast1<-  cbind(contrast1,makeContrasts(contrasts=comparisons[kk], levels=design)   )\n Exp.type = paste(length(g),\" samples detected.\")\n\n# if factorial design 2x2, 2x3, 3x5 etc.\n\t# all samples must be something like WT_control_rep1\nif ( sum(sapply(strsplit(g,\"_\"),length) == 2 ) == length(g) ) {\n\tcomparisons = \"\"\n\t  for( i in 1:(length(g)-1) )\n\t\tfor (j in (i+1):length(g))\n\t\t if( strsplit(g[i],\"_\")[[1]][1] == strsplit(g[j],\"_\")[[1]][1]| strsplit(g[i],\"_\")[[1]][2] == strsplit(g[j],\"_\")[[1]][2]) # only compare WT_control vs. WT_treatment\n\t\t\tcomparisons = c(comparisons,paste(g[j],\"-\",g[i],sep=\"\" ) )\n\t  comparisons <- comparisons[-1]\n\n\textract_treatment <- function (x) paste( gsub( \".*_\",\"\",unlist( strsplit(x,\"-\")) ), collapse=\"-\")\n\textract_genotype <- function (x) gsub( \"_.*\",\"\",unlist( strsplit(x,\"-\")) )[1]\n\textract_treatment_counting <- unique( gsub( \".*_\",\"\",unlist( strsplit(g,\"-\")) ))\n\ttreatments = sapply(comparisons, extract_treatment)\n\tgenotypes = sapply(comparisons, extract_genotype)\n\tExp.type = paste( Exp.type, \"\\nFactorial design:\",length(unique(genotypes)),\"X\", length( extract_treatment_counting ), sep=\"\" )\n\tcontrast1 <- makeContrasts(contrasts=comparisons[1], levels=design)\n\tfor( kk in 2:length(comparisons) )\n\t\t contrast1<-  cbind(contrast1,makeContrasts(contrasts=comparisons[kk], levels=design)   )\n\tcontrast.names = colnames(contrast1)\n\tfor ( kk in 1:(length(comparisons)-1) ) {\n\t   for( kp in (kk+1):length(comparisons))\n\t\t  if( treatments[kp]== treatments[kk] )\n\t\t   {\n\t\t\t  contrast1 = cbind(contrast1, contrast1[,kp]- contrast1[,kk] )\n\t\t\t  contrast.names = c(contrast.names, paste(\"Diff:\",  genotypes[kp], \"-\", genotypes[kk],\"(\",gsub(\"-\",\".vs.\",treatments[kp]),\")\",sep=\"\" ) )\n\t\t   }\n\t}\n\tcolnames(contrast1)=contrast.names\n\tcomparisons = contrast.names\n\t}\n\nfit2 <- contrasts.fit(fit, contrast1)\nfit2 <- eBayes(fit2, trend=limmaTrend)\n#topTable(fit2, coef=1, adjust=\"BH\")\nresults <- decideTests(fit2, p.value=maxP_limma, lfc= log2(minFC_limma ))\n#vennDiagram(results[,1:5],circle.col=rainbow(5))\n top <- function (comp) {\n   tem <- topTable(fit2, number = 1e12,coef=comp,sort.by=\"M\" )\n   if(dim(tem)[1] == 0) return (1) else   return( tem[,c(1,5)])   # no reversing\n                                           #{ tem <-tem[,c(1,5)]; tem[,1] <- -1*tem[,1]; return(tem)  }    # FC is reversed ???\n\n }  # no significant gene returns 1, otherwise a data frame\n topGenes <- lapply(comparisons, top)\n topGenes <- setNames(topGenes, comparisons )\n ix <- which( unlist( lapply(topGenes, class) ) == \"numeric\")\n if( length(ix)>0) topGenes <- topGenes[ - ix ]\n  # if (length(topGenes) == 0) topGenes = NULL;\n}\n return( list(results= results, comparisons = comparisons, Exp.type=Exp.type, topGenes=topGenes))\n}\n\nDEG.DESeq2 <- function (  rawCounts,maxP_limma=.05, minFC_limma=2){\n groups = as.character ( detectGroups( colnames( rawCounts ) ) )\n g = unique(groups)# order is reversed\n\n # check for replicates, removes samples without replicates\n reps = as.matrix(table(groups)) # number of replicates per biological sample\n if ( sum( reps[,1] >= 2) <2 ) # if less than 2 samples with replicates\n return( list(results= NULL, comparisons = NULL, Exp.type=\"Failed to parse sample names to define groups.\n       Cannot perform DEGs and pathway analysis. Please double check column names! Use WT_Rep1, WT_Rep2 etc. \", topGenes=NULL))\n # remove samples without replicates\n g <- rownames(reps)[which(reps[,1] >1)]\n ix <- which( groups %in% g)\n groups <- groups[ix]\n rawCounts <- rawCounts[,ix]\n\n\n Exp.type = paste(length(g),\" samples detected.\")\n  comparisons = \"\"\n  for( i in 1:(length(g)-1) )\n    for (j in (i+1):length(g))\n\t comparisons = c(comparisons,paste(g[j],\"-\",g[i],sep=\"\" ) )\n  comparisons <- comparisons[-1]\n\ncolData = cbind(colnames(rawCounts), groups )\n\n# Set up the DESeqDataSet Object and run the DESeq pipeline\ndds = DESeqDataSetFromMatrix(countData=rawCounts,\n                              colData=colData,\n                              design=~groups)\ndds = DESeq(dds)  # main function\n\nresult1 = NULL; allCalls = NULL;\ntopGenes = list(); pk = 1 # counter\npp=0 # first results?\nfor( kk in 1:length(comparisons) ) {\n\ttem = unlist( strsplit(comparisons[kk],\"-\") )\n\tselected = results(dds, contrast=c(\"groups\", tem[1], tem[2]) ) #, lfcThreshold=log2(minFC_limma))\n\t# selected = subset(res, padj < maxP_limma )\n\tif(dim(selected)[1] == 0 ) next; # no significant genes\n\tselected = selected[order(-abs(selected$log2FoldChange)),]\n\n\tselected$calls =0\n\tselected$calls [which( selected$log2FoldChange > log2(minFC_limma) & selected$padj < maxP_limma ) ]  <-  1\n\tselected$calls [ which( selected$log2FoldChange <  -log2(minFC_limma) & selected$padj < maxP_limma ) ] <-  -1\n\tcolnames(selected)= paste( as.character(comparisons[kk]), \"___\",colnames(selected),sep=\"\" )\n\tselected = as.data.frame(selected)\n\tif (pp==0){  # if first one with significant genes, collect gene list and Pval+ fold\n\t  result1 = selected; pp = 1;\n\t  # selected[,2] <- -1 * selected[,2] # reverse fold change direction\n\t  topGenes[[1]] = selected[,c(2,6)];\n\t  names(topGenes)[1] = comparisons[kk]; } else\n\t\t  { result1 = merge(result1,selected,by=\"row.names\");\n\t\t    rownames(result1) = result1[,1];\n\t\t\tresult1 <- result1[,-1]\n\t\t\tpk= pk+1;\n\t\t\t# selected[,2] <- -1 * selected[,2] # reverse fold change direction\n\t\t\ttopGenes[[pk]] = selected[,c(2,6)];\n\t\t\tnames(topGenes)[pk] = comparisons[kk];\n\t\t  }\n}\n#if( length(comparisons) == 1) topGenes <- topGenes[[1]] # if only one comparison, topGenes is not a list, just a data frame itself.\nif(! is.null(result1)) {\n# note that when you only select 1 column from a data frame it automatically converts to a vector. drop =FALSE prevents that.\nallCalls = as.matrix( result1[,grep(\"calls\",colnames(result1)), drop = FALSE  ] )\ncolnames(allCalls)= gsub(\"___.*\",\"\", colnames(allCalls))\ncolnames(allCalls)= gsub(\"\\\\.\",\"-\", colnames(allCalls)) # note that samples names should have no \".\"\n}\n return( list(results= allCalls, comparisons = comparisons, Exp.type=Exp.type, topGenes=topGenes))\n}\n\npromoter <- function (converted,selectOrg, radio){\n  idNotRecognized = as.data.frame(\"ID not recognized!\")\n  if(is.null(converted) ) return(idNotRecognized) # no ID\n  querySet <- converted$IDs;\n  if(length(querySet) == 0) return(idNotRecognized )\n    ix = grep(converted$species[1,1],motifFiles)\n\n  # If selected species is not the default \"bestMatch\", use that species directly\n  if(selectOrg != speciesChoice[[1]]) {\n    ix = grep(findSpeciesById(selectOrg)[1,1], motifFiles )\n  }\n  ix1 =grep(as.character(radio),motifFiles[ix]) # match 300bp or 600bp\n  if(length(ix1) >0) ix = ix[ix1]   # if 600 is not found, use 300bp\n\n   if (length(ix) == 0 ) {return(as.data.frame(\"No matching motif file found\") )} else {\n  if(length(ix) > 1)  # if only one file\n    return(as.data.frame(\"Multiple geneInfo file found!\") )\n\n motifs <- dbConnect(sqlite,motifFiles[ix]) # makes a new file\n\n  sqlQuery = paste( \" select * from scores where row_names IN ('\", paste(querySet,collapse=\"', '\"),\"')\" ,sep=\"\")\n   result <- dbGetQuery( motifs, sqlQuery  )\n  if( dim(result)[1] ==0) {return(as.data.frame(\"No matching species or gene ID file!\" ) )}\n   row.names(result) <- result$row_names; result <- result[,-1]\n   TFstat <- as.data.frame( cbind(apply(result,2,mean),apply(result,2,sd) ) )\n    colnames(TFstat) = c(\"scoreMean1\",\"scoreSD1\" )\n   rownames(TFstat) = toupper( colnames(result) )\n\n   TFs <- dbGetQuery(motifs, \"select ID,TF_Name,Family_Name,DBID,Motif_ID,coreMotif,memo,nGenes,scoreSD,scoreMean from  TF_Information \")\n   dbDisconnect(motifs)\n   TFs$ID <- toupper(TFs$ID)\n\n   TFs <- merge(TFs, TFstat, by.x = 'ID', by.y='row.names')\n   TFs <- TFs[!is.na(TFs$scoreSD) ,]  #some TFs return NA -Inf\n   n1 = dim(result)[1] # number of genes in query set\n   TFs$scoreMean2 <- (TFs$scoreMean * TFs$nGenes - TFs$scoreMean1 *n1)/(TFs$nGenes - n1)\n   #SD2 needs to be adjusted too, but ignored for now. use overall SD2\n   # t test unequal variance statistic\n   TFs$t <- (TFs$scoreMean1-TFs$scoreMean2)/ sqrt( TFs$scoreSD1^2/n1 + TFs$scoreSD^2/TFs$nGenes   )\n   # degree of freedom\n   TFs$df <- ( TFs$scoreSD1^2/n1 + TFs$scoreSD^2/TFs$nGenes)^2 /\n    (   (TFs$scoreSD1^2/n1)^2/(n1-1) +   (TFs$scoreSD^2/TFs$nGenes)^2/(TFs$nGenes-1)   )\n   TFs$pVal =1-pt(TFs$t,df = TFs$df)  # t distribution\n   TFs$FDR = p.adjust(TFs$pVal,method=\"fdr\")\n   TFs <- TFs[order(TFs$pVal) ,]\n   TFs$scoreDiff = round(TFs$scoreMean1 - TFs$scoreMean2,0)\n   #TFs <- TFs[order(-TFs$scoreDiff) ,]\n\n# does this transcription factor gene in this cluster?\nix <- match(toupper( TFs$DBID), querySet) # assuming the DBID column in cisbp are ensembl gene ids\nTFs$note = \"\"\nif(sum(!is.na(ix)) >0) {\nTFs$note[which(!is.na(ix))] <- \"* Query Gene\"\n}\nTFs <- subset(TFs, FDR<0.25, select=c(coreMotif,TF_Name,Family_Name, pVal,FDR,scoreDiff, note ) )\ncolnames(TFs) =c(\"Motif\", \"TF\",\"TF family\",\"List\",\"FDR\",\"Score\",\"Note\"   )\nif(dim(TFs)[1] >20 ) TFs <- TFs[1:20,]\nif(dim(TFs)[1] ==0) return(as.data.frame(\"No significant TF binding motif detected.\") ) else\nreturn( TFs )\n }\n}\n\n\n\n if(0 ){ # pathway testing\n x = read.csv(\"expression.csv\")\n x = read.csv(\"expression1_no_duplicate.csv\")\n x = read.csv(\"mouse1.csv\")\n x = read.csv(\"GSE40261.csv\")\n x = read.csv(\"GSE52778_All_Sample_FPKM_Matrix.csv\")\n x = read.csv(\"exampleData/GSE87194.csv\")\n  x = read.csv(\"exampleData/expression_3groups.csv\")\n x = x[order(x[,1]),]\n    x = x[!duplicated(x[,1]),]\n    rownames(x)= x[,1]\n    x = x[,-1]\n\n\ttem = apply(x,1,max)\n\tx = x[which(tem> 1),]\n\n\tx = log(x+abs( 1),2)\n\ttem = apply(x,1,sd)\n\tx = x[order(-tem),]\n\n\tselectOrg = \"BestMatch\"; GO=\"GOBP\";\n\tmyrange = c(15,1000)\n\n\tconverted = convertID(rownames(x),selectOrg)\n\n\thead(converted$conversionTable)\n\tmapping = converted$conversionTable\n\n\t   rownames(x) = toupper(rownames(x))\n\t   x1 = merge(mapping[,1:2],x,  by.y = 'row.names', by.x = 'User_input')\n\t  \ttem = apply(x1[,3:(dim(x1)[2]-2)],1,sd)\n\t   x1 = x1[order(x1[,2],-tem),]\n\t   x1 = x1[!duplicated(x1[,2]) ,]\n\t   rownames(x1) = x1[,2]\n\t   x1 = as.matrix(x1[,c(-1,-2)])\n\n\tconvertedData = x1\n    gmt = readGeneSets(converted, convertedData, GO,selectOrg, myrange)\n\n    subtype = detectGroups(colnames(convertedData))\n\tPvalue = 1  # cut off to report in PGSEA. Otherwise NA\n\tPval_pathway = 0.05   # cut off for P value of ANOVA test  to writ to file\n\ttop = 30   # number of pathways to show\n    myrange = c(10,2000)\n\n\tpg = myPGSEA (x,cl=gmt,range=myrange,p.value=TRUE, weighted=FALSE,nPermutation=1)\n\tresult = PGSEApathway (converted,convertedData, selectOrg,GO,gmt, myrange,.05,30)\n\tsmcPlot(result$pg3,factor(subtype),scale = c(-result$best, result$best), show.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5)\n\tsmcPlot(result$pg3,factor(subtype),scale = c(-max(result$pg3), max(result$pg3)), show.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5)\n\n\tpca = 100*prcomp(t(x))$rotation\n\tNpca = 10\n\tif (Npca > dim(pca)[2]) { Npca = dim(pca)[2] } else pca <-  pca[,1:Npca]\n\t#pca = pca[,1:5]\n\tpg = myPGSEA (pca,cl=gmt,range=myrange,p.value=TRUE, weighted=FALSE,nPermutation=1)\n\n\t# correcting for multiple testing\n\tp.matrix = pg$p.result\n\ttem = p.adjust(as.numeric(p.matrix),\"fdr\")\n\tp.matrix = matrix(tem, nrow=dim(p.matrix)[1], ncol = dim(p.matrix)[2] )\n\trownames(p.matrix) = rownames(pg$p.result); colnames(p.matrix) = colnames(pg$p.result)\n\n\t# using absolute value to rank\n \t#selected = unlist( apply(pg$result, 2, function(y) which( rank(y) >= length(y)-3.1)   ) )\n\n\t# using p value to rank #\n\t#selected = unlist( apply(p.matrix, 2, function(x) which( rank(x,ties.method='first') <= 5)   ) )\n\tselected =c()\n\tfor( i in 1:dim(p.matrix)[2]) {\n\t tem = which( rank(p.matrix[,i],ties.method='first') <= 3)\n\t #tem = which( rank(pg$result[,i],ties.method='first') >= dim(p.matrix)[1]-3.1)\n\t names(tem) = paste(\"PC\",i,\" \", rownames(p.matrix)[tem], sep=\"\" )\n\t selected = c(selected, tem)\n\t}\n\trowids = gsub(\" .*\",\"\",names(selected))\n\trowids = as.numeric( gsub(\"PC\",\"\",rowids) )\n\tpvals = p.matrix[ cbind(selected,rowids) ]\n\ta=sprintf(\"%-1.0e\",pvals)\n\ttem = pg$result[selected,]\n\trownames(tem) = paste(a,names(selected)); #colnames(tem)= paste(\"PC\",colnames(tem),sep=\"\")\n\n\ttem = tem[!duplicated(selected),]\n\t#tem = t(tem); tem = t( (tem - apply(tem,1,mean)) ) #/apply(tem,1,sd) )\n\tsmcPlot(tem,scale =  c(-max(tem), max(tem)), show.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5)\n\n\t############  testing D.E.G.\n\tlimma = DEG.limma(convertedData, .1, .5,rawCounts=NULL,countsDEGMethods=1,priorCounts=3, dataFormat=2)\n\tgenes = limma$results\n\t  if( is.null(genes) ) return(NULL)\n\t  ix = match(limma$comparisons, colnames(genes))\n\t  query = rownames(genes)[which(genes[,ix] != 0)]\n      iy = match(query, rownames(convertedData  ) )\n\t  convertedData[iy,]\n      iz= match( detectGroups(colnames(convertedData)), unlist(strsplit( limma$comparisons, \"-\"))\t  )\n      iz = which(!is.na(iz))\n      myheatmap( convertedData[iy,iz] )\n\t # convertedData()[iy,iz]\n\n  \t  # rawCounts = read.csv(\"exampleData/airway_GSE52778.csv\", row.names=1)\n\t   x = read.csv(\"exampleData/GSE87194.csv\") ; x[,1] = toupper(x[,1]);   x = x[order(x[,1]),];    x = x[!duplicated(x[,1]),] #rownames(x)= x[,1]; rawCounts= x[,-1]\n\t   rawCounts = rawCounts[which(apply(rawCounts,1,max )>10 ) ,]\n\t # res =DEG.DESeq2(rawCounts, .05, 2)\n\t # res =\n\t # tem = res$topGenes\n\t # head( res$results )\n\n\t # res2= DEG.limma(rawCounts, .05, 2,rawCounts, 1 ,3)\n\n\n\n\n\n  ######### testing GAGE\n   fc = apply(x1[,4:6],1,mean)- apply(x1[,1:3],1,mean)\n   paths <- gage(fc, gsets = gmt, ref = NULL, samp = NULL)\n\n   paths <- as.data.frame(paths)\n   path1 <- rownames(paths)[1]\n\n\n\n\t  x = read.csv(\"exampleData/airway_GSE52778.csv\", row.names=1)\n\t #x = read.csv(\"exampleData/GSE87194.csv\") ;\n\t x=read.csv(\"GSE37704_sailfish_genecounts.csv\");\n\t #x = read.csv(\"exampleData/counts_test_data_3groups.csv\") ;\n\t x = read.csv(\"exampleData/hoppe 2 samples.csv\")\n\n\t x[,1] = toupper(x[,1]);\n\t colnames(x)[1]= \"User_input\"\n\n\n\tselectOrg = \"BestMatch\"; GO=\"KEGG\";\n\tmyrange = c(15,2000)\n\n\tconverted = convertID(x[,1],selectOrg)\n\tmapping = converted$conversionTable\n\tx = merge(mapping[,1:2],x,   by = 'User_input')\n\ttem = apply(x[,3:(dim(x)[2]-2)],1,sum)\n\tx = x[order(x[,2],-tem),]\n\tx = x[!duplicated(x[,2]) ,]\n\trownames(x) = x[,2]\n\tx = as.matrix(x[,c(-1,-2)])\n\n\tconvertedData = x\n    gmt = readGeneSets(converted, convertedData, GO,selectOrg, myrange)\n\n    res =DEG.DESeq2(x, .25, 1)\n\n\tres <- DEG.limma (x, maxP_limma=.2, minFC_limma=2, x,countsDEGMethods=2,priorCounts=3, dataFormat=1)\n\n    top1 <- res$topGenes[[1]]\n\n    head(top1)\n\n\t paths <- gage(top1[,1,drop=F], gsets = gmt, ref = NULL, samp = NULL)\n\t  paths <-  rbind(paths$greater,paths$less)\n\t  if(dim(paths)[1] < 1 | dim(paths)[2]< 6 ) return( noSig )\n\t  top1 <- paths[,c('stat.mean','set.size','q.val')]\n\t  colnames(top1)= c(\"stat.mean\",\"Set Size\",\"FDR\")\n\t  top1 <- top1[order(top1[,3]) ,]\n\t  if ( length( which( top1[,3] <=  .9   ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1[,3] <=  .9 ) ,]\n\t  if(dim(top1)[1] > 30 )\n\t     top1 <- top1[1:30,]\n\t  top1\n\n\n   \tres = DEG.limma(x, .05, 2,NULL, 1,3 )\n\n ## fgsea\n     top1 <- res$topGenes[[1]]\n    head(top1)\n\tcolnames(top1)= c(\"Fold\",\"FDR\")\n\tfold = top1[,1]; names(fold) <- rownames(top1)\n \t paths <- fgsea(pathways = gmt,\n                  stats = fold,\n                  minSize=15,\n                  maxSize=2000,\n                  nperm=10000)\n if(dim(paths)[1] < 1  ) return( noSig )\n      paths <- as.data.frame(paths)\n\t  top1 <- paths[,c(4,5,7,3)]\n\t  rownames(top1) <- paths[,1]\n\t  colnames(top1)= c(\"ES\",\"NES\",\"Set Size\",\"FDR\")\n\t  top1 <- top1[order(top1[,4]) ,]\n\t  if ( length( which( top1[,4] <=  input$pathwayPvalCutoff   ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1[,4] <=  input$pathwayPvalCutoff ) ,]\n\t  if(dim(top1)[1] > input$nPathwayShow )\n\t     top1 <- top1[1:input$nPathwayShow,]\n\n\t  top1\n\n # testing visualize KEGG pathway\n\n    query = x[1:500,1]\n\t fc= convertEnsembl2Entrez (query, Species)\n\n\t fc = log2(fc/mean(fc))\n\n\t      top1 <- res$topGenes[[1]]\n\t top1 <- top1[,1]; names(top1)= rownames(res$topGenes[[1]] )\n\t  Species = converted$species[1,1]\n\n\tsystem.time(  fc <- convertEnsembl2Entrez (top1, Species)  )\n\t\t fc = sort(fc,decreasing =T)\n\n       head(fc)\n\n\t  system.time ( y<- gsePathway(fc, nPerm=1000,\n                minGSSize=15, pvalueCutoff=0.5,\n                pAdjustMethod=\"BH\", verbose=FALSE) )\n      res <- as.data.frame(y)\n     head(res)\n\n\n\t  # testing mouse\n\t  top1 = limma$topGenes[[1]]\n\t   top1 <- top1[,1]; names(top1)= rownames(limma$topGenes[[1]] )\n\t    Species = converted$species[1,1]\n\t   \tsystem.time(  fc <- convertEnsembl2Entrez (top1, Species)  )\n\t\t\t fc = sort(fc,decreasing =T)\n\t\t\t  system.time ( y<- gsePathway(fc, nPerm=1000,organism = \"mouse\",\n                minGSSize=15, pvalueCutoff=0.5,\n                pAdjustMethod=\"BH\", verbose=FALSE) )\n      res <- as.data.frame(y)\n     head(res)\n\t\tensemblSpecies <- c(\"hsapiens_gene_ensembl\",\"rnorvegicus_gene_ensembl\", \"mmusculus_gene_ensembl\",\n\t\t\"celegans_gene_ensembl\",\"scerevisiae_gene_ensembl\", \"drerio_gene_ensembl\", \"dmelanogaster_gene_ensembl\")\n         ReactomePASpecies= c(\"human\", \"rat\", \"mouse\", \"celegans\", \"yeast\", \"zebrafish\", \"fly\" )\n\n\n  #### testing KEGG pathway graph\n x=read.csv(\"GSE37704_sailfish_genecounts.csv\");\n\t #x = read.csv(\"exampleData/counts_test_data_3groups.csv\") ;\n\t x[,1] = toupper(x[,1]);\n\t colnames(x)[1]= \"User_input\"\n\n\n\tselectOrg = \"BestMatch\"; GO=\"KEGG\";\n\tmyrange = c(15,2000)\n\n\tconverted = convertID(x[,1],selectOrg)\n\tmapping = converted$conversionTable\n\tx = merge(mapping[,1:2],x,   by = 'User_input')\n\ttem = apply(x[,3:(dim(x)[2]-2)],1,sum)\n\tx = x[order(x[,2],-tem),]\n\tx = x[!duplicated(x[,2]) ,]\n\trownames(x) = x[,2]\n\tx = as.matrix(x[,c(-1,-2)])\n\n\tconvertedData = x\n    gmt = readGeneSets(converted, convertedData, GO,selectOrg, myrange)\n\n    res =DEG.DESeq2(x, .25, 1)\n\n    top1 <- res$topGenes[[1]]\n\n    head(top1)\n\n\t paths <- gage(top1[,1,drop=F], gsets = gmt, ref = NULL, samp = NULL)\n\t  paths <-  rbind(paths$greater,paths$less)\n\n\tselectedPathway = rownames(paths)[1]\n   # [1] \"Cytokine-cytokine receptor interaction\"\n\n\t    Species <- converted$species[1,1]\n\n\t fold = top1[,1]; names(fold) <- rownames(top1)\n\t fold <- convertEnsembl2Entrez(fold,Species)\n\n     keggSpecies <- as.character( keggSpeciesID[which(keggSpeciesID[,1] == Species),3] )\n\n     if(nchar( keggSpecies) <=2 ) return(blank) # not in KEGG\n\tcat(\"here5  \",keggSpecies, \" \",Species,\" \",input$sigPathways)\n\t # kegg pathway id\n\tpathID = keggPathwayID(selectedPathway, Species, \"KEGG\",selectOrg)\n\n\tcat(\"\\n\",fold[1:5],\"\\n\",keggSpecies,\"\\n\",pathID)\n    if(is.null(pathID) ) return(blank) # kegg pathway id not found.\n\tpv.out <- pathview(gene.data = fold, pathway.id = pathID, species = keggSpecies, kegg.native=TRUE)\n\n\t#######################################\n\t# testing for species not recognized\n\tx=read.csv(\"exampleData/Wu_wet_vs_control - new species.csv\");\n\t #x = read.csv(\"exampleData/counts_test_data_3groups.csv\") ;\n\t x[,1] = toupper(x[,1]);\n\t colnames(x)[1]= \"User_input\"\n\tselectOrg = \"BestMatch\"; GO=\"KEGG\";\n\tmyrange = c(15,2000)\n\tconverted = convertID(x[,1],selectOrg)\n\tmapping = converted$conversionTable\n }\n\ndebug_prep <- function () {\n  inFile = \"C:/Users/Xijin.Ge/Google Drive/research/Shiny/RNAseqer/expression1_no_duplicate.csv\"\n  # inFile = \"C:/Users/Xijin.Ge/Google Drive/research/Shiny/RNAseqer/GSE52778_All_Sample_FPKM_Matrix.csv\"\n  lowFilter = 1; logStart = 1\n  x = read.csv(inFile)\n\tx[,1] = toupper(x[,1])\n  x = x[order(x[,1]),]\n  x = x[!duplicated(x[,1]),]\n  rownames(x)= x[,1]\n  x = x[,-1]\n\ttem = apply(x,1,max)\n\tx = x[which(tem> lowFilter),]\n\tx = log(x+abs( logStart),2)\n\ttem = apply(x,1,sd)\n\tx = x[order(-tem),]\n  ###########Converted data\n\tconvertedID = convertID(rownames(x ),selectOrg=\"BestMatch\", selectGO = \"GOBP\" );#\"gmax_eg_gene\"\n\tmapping <- convertedID$conversionTable\n  rownames(x) = toupper(rownames(x))\n\tx1 = merge(mapping[,1:2],x,  by.y = 'row.names', by.x = 'User_input')\n\ttem = apply(x1[,3:(dim(x1)[2]-2)],1,sd)\n\tx1 = x1[order(x1[,2],-tem),]\n\tx1 = x1[!duplicated(x1[,2]) ,]\n\trownames(x1) = x1[,2]\n\tx1 = as.matrix(x1[,c(-1,-2)])\n  tem = apply(x1,1,sd)\n\tx1 = x1[order(-tem),]\n\tx=x1\n\thead(x)\n\t\n  #################################\n\t#testing Kmeans\n\tx=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\t#x = 100* x / apply(x,1,sum)  # this is causing problem??????\n\t#x = x - apply(x,1,mean)  # this is causing problem??????\n\t#colnames(x) = gsub(\"_.*\",\"\",colnames(x))\n\tset.seed(2)\n\t# determining number of clusters\n\tk=6\n\n\tcl = kmeans(x,k,iter.max = 50)\n\t#myheatmap(cl$centers)\n\n\thc <- hclust2(dist2(cl$centers-apply(cl$centers,1,mean) )  )# perform cluster for the reordering of samples\n\ttem = match(cl$cluster,hc$order) #  new order\n\n\tx = x[order(tem),]\n\n\tbar = sort(tem)\n\t#myheatmap2(x, bar)\n    # GO\n\tpp=0\n\tfor( i in 1:k) {\n\t#incProgress(1/k, , detail = paste(\"Cluster\",toupper(letters)[i]) )\n\tquery = rownames(x)[which(bar == i)]\n\tconvertedID = convertID(query,\"BestMatch\", selectGO = \"GOBP\" );#\"gmax_eg_gene\"\n\ttem = geneInfo(convertedID,\"BestMatch\") #input$selectOrg ) ;\n\ttem <- tem[which( tem$Set == \"List\"),]\n\n\n\t#selectOrg = input$selectOrg\n\tselectOrg =\"BestMatch\"\n\n\tresult = FindOverlap (convertedID,tem, \"GOBP\",selectOrg,1)\n\tif( dim(result)[2] ==1) next;   # result could be NULL\n\tresult$Genes = toupper(letters)[i]\n\tif (pp==0 ) { results = result; pp = 1;} else  results = rbind(results,result)\n\n\n\t}\n\tresults= results[,c(5,1,2,4)]\n\tcolnames(results)= c(\"Cluster\",\"FDR\",\"Genes\",\"GO BP Terms\")\n\tminFDR = 0.05\n\tif(min(results$FDR) > minFDR ) results = as.matrix(\"No signficant enrichment found.\") else\n\tresults = results[which(results$FDR < minFDR),]\n\t}\n\nshinyServer(\n  function(input, output,session) {\n\n demoDataFile = \"GSE37704_sailfish_genecounts.csv\" #\"expression1_no_duplicate.csv\"\n #-----------------------------------------------\n # Available datasets\n # readData()$data: transformed data, readData()$rawCounts: Counts data. NULL if non-count data.\n # converted():id conversion results with many components such as: converted()$originalIDs,  converted()$IDs: converted IDs\n               #,converted()$species,   converted()$speciesMatched,  converted()$conversionTable\n # allGeneInfo(): returns all information in the geneInfo file for each gene\n # geneSets(): gene set as a list for pathway analysis\n\noptions(shiny.maxRequestSize = 50*1024^2) # 50MB file max for upload\nobserve({ updateSelectInput(session, \"selectOrg\", choices = speciesChoice )})\n\n# read data file\nreadData <- reactive ({\n  inFile <- input$file1\n\tinFile <- inFile$datapath\n  if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n\tif (is.null(input$file1) && input$goButton > 0 )   inFile = demoDataFile\n\ttem = input$dataFileFormat\n\tif( !is.null(input$dataFileFormat) ) # these are needed to make it responsive to changes\n    if(input$dataFileFormat== 1)\n    \t{  tem = input$minCounts ; tem = input$countsLogStart; tem=input$CountsTransform }\n\tif( !is.null(input$dataFileFormat) )\n    if(input$dataFileFormat== 2)\n    { tem = input$transform; tem = input$logStart; tem= input$lowFilter }\n\t\n\t\n\tisolate({\n  \twithProgress(message=\"Reading and pre-processing \", {\n    \tif (is.null( input$dataFileFormat )) return(NULL)\n    \tdataTypeWarning =0\n  \t\t#---------------Read file\n  \t\tx <- read.csv(inFile)\t# try CSV\n          if(dim(x)[2] <= 2 )   # if less than 3 columns, try tab-deliminated\n  \t\tx <- read.table(inFile, sep=\"\\t\",header=TRUE)\n  \t\t#-------Remove non-numeric columns, except the first column\n  \t\tdataType =c(TRUE)\n          for( i in 2:dim(x)[2])\n  \t\t\tdataType = c( dataType, is.numeric(x[,i]) )\n  \t\tif(sum(dataType) <=2) return (NULL)  # only less than 2 columns are numbers\n  \t\tx <- x[,dataType]  # only keep numeric columns\n  \n  \t\tx[,1] <- toupper(x[,1])\n  \t\tx = x[order(- apply(x[,2:dim(x)[2]],1,sd) ),]  # sort by SD\n  \t\tx <- x[!duplicated(x[,1]) ,]  # remove duplicated genes\n  \t\trownames(x) <- x[,1]\n  \t\tx <- as.matrix(x[,c(-1)])\n  \n  \t\t# imput missing data using median\n          if( sum( is.na(x)) > 0 ) {     # if there is missing values\n  \t\t  rowMeans <- apply(x,1, function (y)  median(y,na.rm=T))\n  \t\t  for( i in 1:dim(x)[1] )\n  \t\t   x[i, which( is.na(x[i,]) )  ]  <- rowMeans[i]\n  \t\t}\n  \n  \t\t# Compute kurtosis\n  \t\tmean.kurtosis = mean( apply(x,2, kurtosis) )\n      if (input$dataFileFormat == 2 ) {  # if FPKM, microarray\n  \t    incProgress(1/3,\"Pre-processing data\")\n  \t\tif ( is.integer(x) ) dataTypeWarning = 1;  # Data appears to be read counts\n  \t\t#-------------filtering\n  \t\ttem <- apply(x,1,max)\n  \t\tx <- x[which(tem > input$lowFilter),]  # max by row is at least\n  \t\tx <- x[which(apply(x,1, function(y) max(y)- min(y) ) > 0  ),]  # remove rows with all the same levels\n  \n  \t\t#--------------Log transform\n  \t\t# Takes log if log is selected OR kurtosis is big than 100\n  \t\tif ( (input$transform == TRUE) | (mean.kurtosis > kurtosis.log ) )\n  \t\t\tx = log(x+abs( input$logStart),2)\n  \t\tprint(abs( input$logStart))\n  \t\ttem <- apply(x,1,sd)\n  \t\tx <- x[order(-tem),]  # sort by SD\n  \t\trawCounts = NULL\n     } else {  # counts data\n  \t\tincProgress(1/3, \"Pre-processing counts data\")\n  \n  \t\ttem = input$CountsDEGMethod; tem = input$countsTransform\n  \n  \t\t# data not seems to be read counts\n  \t\tif(!is.integer(x) & mean.kurtosis < kurtosis.log ) dataTypeWarning = -1\n  \n  \t\tvalidate(   # if Kurtosis is less than a threshold, it is not read-count\n  \t\t\tneed(mean.kurtosis > kurtosis.log, \"Data does not seem to be read count based on distribution. Please double check.\")\n  \t\t)\n  \n  \t\tx <- round(x,0) # enforce the read counts to be integers. Sailfish outputs has decimal points.\n  \t\tx <- x[ which( apply(x,1,max) >= input$minCounts ) , ] # remove all zero counts\n  \n  \t\tif(0){  # disabled\n  \t\t\t# remove genes with low expression by counts per million (CPM)\n  \t\t\tdge <- DGEList(counts=x); dge <- calcNormFactors(dge)\n  \t\t\tmyCPM <- cpm(dge, prior.counts = 3 )\n  \t\t\tx <- x[which(rowSums(  myCPM > input$minCounts)  > 1 ),]  # at least two samples above this level\n  \t\t\trm(dge); rm(myCPM)\n  \t\t}\n  \n  \t\trawCounts = x;\n  \n  \t\t# construct DESeqExpression Object\n  \t\t# colData = cbind(colnames(x), as.character(detectGroups( colnames(x) )) )\n  \t\ttem = rep(\"A\",dim(x)[2]); tem[1] <- \"B\"   # making a fake design matrix to allow process, even when there is no replicates\n  \t\tcolData = cbind(colnames(x), tem )\n  \t\tcolnames(colData)  = c(\"sample\", \"groups\")\n  \t\tdds <- DESeqDataSetFromMatrix(countData = x,\n                                    colData = colData,\n                                    design = ~ groups)\n  \t\tdds <- estimateSizeFactors(dds) # estimate size factor for use in normalization later for started log method\n  \t\tincProgress(1/2,\"transforming raw counts\")\n  \t\t# regularized log  or VST transformation\n  \t\tif( input$CountsTransform == 3 && dim(counts(dds))[2] <= 10 )  # rlog is slow, only do it with 10 samples\n  \t\t    { x <- rlog(dds, blind=FALSE); x <- assay(x) } else {\n  \t\t\tif ( input$CountsTransform == 2 )    # vst is fast but aggressive\n  \t\t\t   { x <- vst(dds, blind=FALSE); x <- assay(x)  } else{  # normalized by library sizes and add a constant.\n  \t\t\t\t    x <- log2( counts(dds, normalized=TRUE) + input$countsLogStart )   # log(x+c)\n  \t\t\t\t}\n  \t\t\t}\n  \n     }\n         incProgress(1, \"Done.\")\n  \n      return( list(data = as.matrix(x), mean.kurtosis = mean.kurtosis, rawCounts = rawCounts, dataTypeWarning=dataTypeWarning) )\n\t })\n\t})\n  })\n\noutput$text.transform <- renderText({\n      if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\t  inFile <- input$file1\n\n\t  k.value =  readData()$mean.kurtosis\n      tem = paste( \"Mean Kurtosis =  \", round(k.value,2), \".\\n\",sep = \"\")\n\t  if( k.value > kurtosis.log) tem = paste(tem, \" Detected extremely large numbers with kurtosis >\", kurtosis.log,\n   \t  \". Log transformation is automatically applied, even user selects otherwise.\", sep=\"\") else if (k.value>kurtosis.warning)\n\t  {tem = paste(tem, \" Detected  large numbers with kurtosis >\",\n   \t  kurtosis.warning,\". Log transformation is recommended.\", sep=\"\") }\n\n\t  if(readData()$dataTypeWarning == 1 ) {\n\t      tem = paste (tem, \" ------Warning!!! Data matrix contains all integers. It seems to be read counts!!! Please select appropriate data type in the previous page and reload file.\")}\n\t  if(readData()$dataTypeWarning == -1 ) {\n\t       tem = paste (tem, \"  ------Warning!!! Data does not look like read counts data. Please select appropriate data type in the previous page and reload file.\")}\n\n\t  tem\n\n\t})\n\noutput$fileFormat <- renderText({\n\t\t\" Upload CSV (comma separated value) files containing gene expression data derived from RNA-seq or microarray.\n\t\tFor RNA-seq data, gene-level read count data is recommended, but FPKM or RPKM data also acceptable.\n\t  iDEP can convert most types of common gene ids to Ensembl gene IDs. Name samples in each column carefully as iDEP parses them to define sample groups.\n\t  Replicates should be denotated by \\\"_Rep1,2,3...\\\" at the end. For example,\n\t  Control_Rep1, Control_Rep2, Treatment_Rep1, Treatment_Rep2. For factorial experiment design, use underscore \\\"_\\\" to\n\t  separate factors such as genetic background and treatment. For example,\n      WT_control_Rep1, WT_control_Rep2, WT_Treatment_Rep1, WT_treatment_Rep2,\n\t\tMu_control_Rep1, Mu_control_Rep2, Mu_Treatment_Rep1, Mu_treatment_Rep2.\n\t\tAlso, avoid using hyphen \\\"-\\\" or dot \\\".\\\" in sample names.\"\n\t})\n\n# this defines an reactive object that can be accessed from other rendering functions\nconverted <- reactive({\n\t  if (is.null(input$file1) && input$goButton == 0)    return(NULL)\n       tem = input$selectOrg;\n      isolate( {\n   #   withProgress(message=\"Converting gene ids\", {\n     # cat (paste(\"\\nID:\",input$selectOrg) )\n\t  convertID(rownames(readData()$data ),input$selectOrg, input$selectGO );\n\n\t # })\n\t  })\n\n\t} )\n\n# this defines an reactive object that can be accessed from other rendering functions\nallGeneInfo <- reactive({\n\t  if (is.null(input$file1) && input$goButton == 0)    return(NULL)\n       tem = input$selectOrg;\n      isolate( {\n      withProgress(message=\"Looking up gene annotation\", {\n\t  geneInfo(converted(),input$selectOrg);\n\t\t\t })\n\t  })\n\t} )\n\nconvertedData <- reactive({\n\t  if (is.null(input$file1) && input$goButton == 0)    return()\n\t\ttem = input$selectOrg;  tem = input$lowFilter ; tem = input$transform;\n      if( is.null(converted() ) ) return( readData()$data) # if id or species is not recognized use original data.\n\t  isolate( {\n\t   mapping <- converted()$conversionTable\n      # cat (paste( \"\\nData:\",input$selectOrg) )\n\t   x =readData()$data\n\t   rownames(x) = toupper(rownames(x))\n\n\t  # any gene not recognized by the database is disregarded\n\t  # x1 = merge(mapping[,1:2],x,  by.y = 'row.names', by.x = 'User_input')\n\n\t   # the 3 lines keeps the unrecogized genes using original IDs\n\t   x1 = merge(mapping[,1:2],x,  by.y = 'row.names', by.x = 'User_input', all.y=TRUE)\n\t   ix = which(is.na(x1[,2]) )\n\t   x1[ix,2] = x1[ix,1] # original IDs used\n\t   #write.csv(x1,\"tem.csv\")\n\n\t   tem = apply(x1[,3:(dim(x1)[2])],1,sd)\n\t   x1 = x1[order(x1[,2],-tem),]\n\t   x1 = x1[!duplicated(x1[,2]) ,]\n\t   rownames(x1) = x1[,2]\n\t   x1 = as.matrix(x1[,c(-1,-2)])\n\t   tem = apply(x1,1,sd)\n\t   x1 = x1[order(-tem),]  # sort again by SD\n       return(x1)\n\t  })\n\n\t} )\n\nGeneSets <- reactive({\n\t  if (is.null(input$file1) && input$goButton == 0)    return()\n\n\t  tem = input$selectOrg\n\t  tem = input$selectGO\n\t  tem =input$minSetSize; tem= input$maxSetSize\n      isolate( {\n\t\tif(input$selectOrg == \"NEW\" && !is.null(input$gmtFile) ) # new species\n\t\t  {     inFile <- input$gmtFile; inFile <- inFile$datapath\n\t\t     return( readGMTRobust(inFile) ) }else\n\t   return( readGeneSets( converted(), convertedData(), input$selectGO,input$selectOrg,c(input$minSetSize, input$maxSetSize)  ) ) })\n\t} )\n\noutput$contents <- renderTable({\n  inFile <- input$file1\n  inFile <- inFile$datapath\n  if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n  #if (is.null(input$file1) && input$goButton > 0 )   inFile = \"expression1_no_duplicate.csv\"\n\tif (is.null(input$file1) && input$goButton > 0 )   inFile = demoDataFile\n\ttem = input$selectOrg\n\tisolate({\n\tx <- read.csv(inFile)\n\tif(dim(x)[2] <= 2 ) x <- read.table(inFile, sep=\"\\t\",header=TRUE)\t# not CSV\n    #x <- readData()$data\n     x[1:20,]\n\t})\n  },include.rownames=FALSE)\n\noutput$species <-renderTable({\n      if (is.null(input$file1) && input$goButton == 0)    return()\n      isolate( {  #tem <- convertID(input$input_text,input$selectOrg );\n\t  \t  withProgress(message=\"Converting gene IDs\", {\n                  tem <- converted()\n\t\t\tincProgress(1, detail = paste(\"Done\"))\t  })\n\n\t\t\t\t  if( is.null(tem)) {as.data.frame(\"ID not recognized.\")} else {\n\t              tem$speciesMatched }\n\n      }) # avoid showing things initially\n    }, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\noutput$EDA <- renderPlot({\n  if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n  x <- readData()$data\n\tpar(mfrow=c(3,1))\n\tpar(mar=c(8,4,4,4))\n\tmyColors = rainbow(dim(x)[2])\n\tplot(density(x[,1]),col = myColors[1],xlab=\"Expresson values\", ylab=\"Density\", main= \"Distribution of transformed data\")\n\tfor( i in 2:dim(x)[2] )\n\tlines(density(x[,i]),col=myColors[i] )\n    legend(\"topright\", colnames(x), lty=rep(1,dim(x)[2]), col=myColors )\n   # boxplot of first two samples, often technical replicates\n\tboxplot(x, las = 2, ylab=\"Transformed expression levels\", main=\"Distribution of transformed data\")\n\tplot(x[,1:2],xlab=colnames(x)[1],ylab=colnames(x)[2], main=\"Scatter plot of first two samples\")\n\n   }, height = 1500, width = 500)\n\noutput$correlationMatrix <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    # heatmap of correlation matrix\n\tx <- readData()$data\n\tmaxGene <- apply(x,1,max)\n\tx <- x[which(maxGene > quantile(maxGene)[1] ) ,] # remove bottom 25% lowly expressed genes, which inflate the PPC\n\n   melted_cormat <- melt(round(cor(x),2), na.rm = TRUE)\n  # melted_cormat <- melted_cormat[which(melted_cormat[,1] != melted_cormat[,2] ) , ]\n\t# Create a ggheatmap\n\tggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+\n\t geom_tile(color = \"white\")+\n\t scale_fill_gradient2(low = \"green\", high = \"red\",  mid = \"white\",\n\t\tspace = \"Lab\",  limit = c(min(melted_cormat[,3]) ,max(melted_cormat[,3])), midpoint = median(melted_cormat[,3]),\n\t\tname=\"Pearson\\nCorrelation\"\n\t  ) +\n\t  theme_minimal()+ # minimal theme\n\t theme(axis.text.x = element_text(angle = 45, vjust = 1,\n\t\tsize = 12, hjust = 1))+\n\t coord_fixed()\n\t# print(ggheatmap)\n\t ggheatmap +\n\tgeom_text(aes(Var2, Var1, label = value), color = \"black\", size = 4) +\n\ttheme(\n\t  axis.title.x = element_blank(),\n\t  axis.title.y = element_blank(),\n\t  panel.grid.major = element_blank(),\n\t  panel.border = element_blank(),\n\t  panel.background = element_blank(),\n\t  axis.ticks = element_blank(),\n\t legend.justification = c(1, 0),\n\t  legend.position = c(0.6, 0.7),\n\t legend.direction = \"horizontal\")+\n\t guides(fill = FALSE) + ggtitle(\"Pearson's Correlation Coefficient (all genes)\")\n\n\n  } , height = 600, width = 600)\n\nprocessedData <- reactive({\n      if (is.null(input$file1) && input$goButton == 0)    return()\n\t\tif(input$selectOrg == \"NEW\") return(  convertedData() ) else\n\t  return( merge(allGeneInfo()[,c('ensembl_gene_id','symbol')], round(convertedData(),4),by.x=\"ensembl_gene_id\", by.y =\"row.names\", all.y=T ))\n})\n\noutput$downloadProcessedData <- downloadHandler(\n     filename = function() {\"processed_Data.csv\"},\n\t\tcontent = function(file) {\n      write.csv( processedData(), file )\t    }\n)\n\noutput$examineData <- DT::renderDataTable({\n   inFile <- input$file1\n\tinFile <- inFile$datapath\n    if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n\n\ttem = input$selectOrg\n\tisolate({\n\tmerge(allGeneInfo()[,c('ensembl_gene_id','symbol')], round(convertedData(),2),by.x=\"ensembl_gene_id\", by.y =\"row.names\", all.y=T )\n\t})\n  })\n\noutput$totalCounts <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    if (is.null(readData()$rawCounts))   return(NULL)\n    par(mar=c(10,2,2,2))\n    x <- readData()$rawCounts\n\tbarplot( colSums(x)/1e6, col=\"green\",las=3, main=\"Total read counts (millions)\")\n\n})\n\noutput$PCA <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\n\tx <- convertedData();\n     if(input$PCA_MDS ==1) {   #PCA\n\t pca.object <- prcomp(t(x))\n\t # par(mfrow=c(2,1))\n\tif(0){\n     plot( pca.object$x[,1], pca.object$x[,2], pch = 1,cex = 2,col = detectGroups(colnames(x)),\n\t     xlim=c(min(pca.object$x[,1]),max(pca.object$x[,1])*1.5   ),\n\t\txlab = \"First principal component\", ylab=\"Second Principal Component\")\n\t\ttext( pca.object$x[,1], pca.object$x[,2],  pos=4, labels =colnames(x), offset=.5, cex=.8)\n\t\t}\n\n\tpcaData = as.data.frame(pca.object$x[,1:2]); pcaData = cbind(pcaData,detectGroups(colnames(x)) )\n\tcolnames(pcaData) = c(\"PC1\", \"PC2\", \"Type\")\n\tpercentVar=round(100*summary(pca.object)$importance[2,1:2],0)\n\tp=ggplot(pcaData, aes(PC1, PC2, color=Type, shape = Type)) + geom_point(size=5)\n\tp=p+xlab(paste0(\"PC1: \",percentVar[1],\"% variance\"))\n\tp=p+ylab(paste0(\"PC2: \",percentVar[2],\"% variance\"))\n\tp=p+ggtitle(\"Principal component analysis (PCA)\")+coord_fixed(ratio=1.0)+\n     theme(plot.title = element_text(hjust = 0.5)) + theme(aspect.ratio=1)\n\t   print(p)\n\t   }\n\t# variance chart\n\t# plot(pca.object,type=\"bar\", xlab=\"Principal Components\", main =\"Variances explained\")\n\n\t# pathways\n\tif(input$PCA_MDS ==2) {\n\twithProgress(message=\"Running pathway analysis\", {\n\tpca.object <- prcomp(t(x))\n\tpca = 100*pca.object$rotation\n\tNpca = 5\n\tif (Npca > dim(pca)[2]) { Npca = dim(pca)[2] } else pca <-  pca[,1:Npca]\n\t#pca = pca[,1:5]\n\tif(is.null(GeneSets() ) ) return(NULL)  # no species recognized\n\tif(length(GeneSets() ) <= 1 ) return(NULL)\n\t#cat(\"\\n\\nGene Sets:\",length( GeneSets()))\n\tpg = myPGSEA (pca,cl=GeneSets(),range=c(15,2000),p.value=TRUE, weighted=FALSE,nPermutation=1)\n\tincProgress(2/8)\n\t# correcting for multiple testing\n\tp.matrix = pg$p.result\n\ttem = p.adjust(as.numeric(p.matrix),\"fdr\")\n\tp.matrix = matrix(tem, nrow=dim(p.matrix)[1], ncol = dim(p.matrix)[2] )\n\trownames(p.matrix) = rownames(pg$p.result); colnames(p.matrix) = colnames(pg$p.result)\n\n\n\tselected =c()\n\tfor( i in 1:dim(p.matrix)[2]) {\n\t  tem = which( rank(p.matrix[,i],ties.method='first') <= 5)  # rank by P value\n\t #tem = which( rank(pg$result[,i],ties.method='first') >= dim(p.matrix)[1]-3.1) # rank by mean\n\t names(tem) = paste(\"PC\",i,\" \", rownames(p.matrix)[tem], sep=\"\" )\n\t selected = c(selected, tem)\n\t}\n\trowids = gsub(\" .*\",\"\",names(selected))\n\trowids = as.numeric( gsub(\"PC\",\"\",rowids) )\n\tpvals = p.matrix[ cbind(selected,rowids) ]\n\ta=sprintf(\"%-1.0e\",pvals)\n\ttem = pg$result[selected,]\n\trownames(tem) = paste(a,names(selected)); #colnames(tem)= paste(\"PC\",colnames(tem),sep=\"\")\n\n\ttem = tem[!duplicated(selected),]\n\tincProgress(3/8)\n\t#tem = t(tem); tem = t( (tem - apply(tem,1,mean)) ) #/apply(tem,1,sd) )\n\n\tsmcPlot(tem,scale =  c(-max(tem), max(tem)), show.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5, main=\"Pathways analysis on PCA\")\n\t } )\n\t }\n\n\tif(input$PCA_MDS ==3) {  # MDS\n\t fit = cmdscale( dist2(t(x) ), eig=T, k=2)\n\n\t# par(pin=c(5,5))\n\tif(0) {\n\tplot( fit$points[,1],fit$points[,2],pch = 1,cex = 2,col = detectGroups(colnames(x)),\n\t     xlim=c(min(fit$points[,1]),max(fit$points[,1])*1.5   ),\n\t  xlab = \"First dimension\", ylab=\"Second dimension\"  )\n\t text( fit$points[,1], fit$points[,2],  pos=4, labels =colnames(x), offset=.5, cex=1)\n\t}\n\tpcaData = as.data.frame(fit$points[,1:2]); pcaData = cbind(pcaData,detectGroups(colnames(x)) )\n\tcolnames(pcaData) = c(\"x1\", \"x2\", \"Type\")\n\n\tp=ggplot(pcaData, aes(x1, x2, color=Type, shape = Type)) + geom_point(size=5)\n\t#p=p+xlab(paste0(\"PC1: \",percentVar[1],\"% variance\"))\n\t#p=p+ylab(paste0(\"PC2: \",percentVar[2],\"% variance\"))\n\tp=p+ggtitle(\"Multidimensional scaling (MDS)\")+ coord_fixed(ratio=1.)+\n     theme(plot.title = element_text(hjust = 0.5)) + theme(aspect.ratio=1)\n\t   print(p)\n\n\t }\n\n  }, height = 500, width = 500)\n\nPCAdata <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    x <- readData()$data\n\n\t result = prcomp(t(x))$x[,1:2]\n\t fit = cmdscale( dist2(t(x) ), eig=T, k=2)\n     result = cbind( result, fit$points[,1:2] )\n\t colnames(result) = c(\"PCA.x\",\"PCA.y\",\"MDS.x\", \"MDS.y\")\n\t return( result)\n  })\n\noutput$downloadPCAData <- downloadHandler(\n     filename = function() {\"PCA_and_MDS.csv\"},\n\t\tcontent = function(file) {\n          write.csv(PCAdata(), file)\n\t    }\n  )\n\nKmeans <- reactive({ # Kmeans clustering\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\twithProgress(message=\"k-means clustering\", {\n    x <- convertedData()\n\t#x <- readData()\n\t#par(mfrow=c(1,2))\n\tn=input$nGenesKNN\n\tif(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\t#x1 <- x;\n\t#x=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\tx = 100* x[1:n,] / apply(x[1:n,],1,sum)\n\t#x = x - apply(x,1,mean)  # this is causing problem??????\n\t#colnames(x) = gsub(\"_.*\",\"\",colnames(x))\n\tset.seed(2)\n\tk=input$nClusters\n\n\tcl = kmeans(x,k,iter.max = 50)\n\t#myheatmap(cl$centers)\n\n   incProgress(.3, detail = paste(\"Heatmap...\"))\n\thc <- hclust2(dist2(cl$centers-apply(cl$centers,1,mean) )  )# perform cluster for the reordering of samples\n\ttem = match(cl$cluster,hc$order) #  new order\n\tx = x[order(tem),] ; \tbar = sort(tem)\n\t\tincProgress(1, detail = paste(\"Done\")) }) #progress\n\t#myheatmap2(x-apply(x,1,mean), bar,1000)\n\treturn(list( x = x, bar = bar))\n\n  } )\n\noutput$KmeansHeatmap <- renderPlot({ # Kmeans clustering\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\tif( is.null(Kmeans()) ) return(NULL)\n\twithProgress(message=\"Creating heatmap\", {\n\n\tmyheatmap2(Kmeans()$x-apply(Kmeans()$x,1,mean), Kmeans()$bar,1000)\n\n\tincProgress(1, detail = paste(\"Done\")) }) #progress\n  } , height = 500, width = 500)\n\noutput$KmeansNclusters <- renderPlot({ # Kmeans clustering\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\twithProgress(message=\"k-means clustering\", {\n    x <- convertedData()\n\t#x <- readData()\n\t#par(mfrow=c(1,2))\n\tn=input$nGenesKNN\n\tif(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\t#x1 <- x;\n\t#x=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\tx = 100* x[1:n,] / apply(x[1:n,],1,sum)  # this is causing problem??????\n\t#x = x - apply(x,1,mean)  # this is causing problem??????\n\t#colnames(x) = gsub(\"_.*\",\"\",colnames(x))\n\tset.seed(2)\n\t# determining number of clusters\n\tincProgress(.3, detail = paste(\"Performing k-means...\"))\n\n\tk = 30\n\twss <- (nrow(x)-1)*sum(apply(x,2,var))\n\t  for (i in 2:k) wss[i] <- sum(kmeans(x,centers=i,iter.max = 30)$withinss)\n\tplot(1:k, wss, type=\"b\", xlab=\"Number of Clusters (k)\",\n\t\t ylab=\"Within groups sum of squares\")\n\n\n\tincProgress(1, detail = paste(\"Done\")) }) #progress\n  } , height = 500, width = 500)\n\nKmeansData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\tif( is.null(Kmeans()) ) return(NULL)\n\n\t#myheatmap2(x, bar)\n\tCluster <- toupper(letters)[Kmeans()$bar]\n\tx <- cbind(Cluster,Kmeans()$x)\n\n\t\t# add gene symbol\n\tif( input$selectOrg != \"NEW\")\n\t{ ix <- match( rownames(x), allGeneInfo()[,1])\n\t  x <- cbind(as.character( allGeneInfo()$symbol)[ix],x) }\n\treturn(x)\n\n\t #progress\n  })\n\noutput$downloadDataKmeans <- downloadHandler(\n     filename = function() {\"Kmeans.csv\"},\n\t\tcontent = function(file) {\n      write.csv(KmeansData(), file)\n\t    }\n  )\n\noutput$KmeansGO <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectGO3\n\tif( is.null(input$selectGO3 ) ) return (NULL)\n\tif( input$selectGO3 == \"ID not recognized!\" ) return ( as.matrix(\"Gene ID not recognized.\") )#No matching species\n   \tif( is.null(Kmeans()) ) return(NULL)\n\tif(input$selectOrg == \"NEW\" && is.null( input$gmtFile) ) return(NULL) # new but without gmtFile\n\twithProgress(message=\"GO Enrichment\", {\n\n    # GO\n\tpp=0\n\tfor( i in 1:input$nClusters) {\n\tincProgress(1/input$nClusters, , detail = paste(\"Cluster\",toupper(letters)[i]) )\n\tquery = rownames(Kmeans()$x)[which(Kmeans()$bar == i)]\n\n\tif(input$selectOrg == \"NEW\" && !is.null( input$gmtFile) )\n\t{ result <- findOverlapGMT( query, GeneSets(),1) } else {\n\t\tconvertedID <- converted()\n\t\tconvertedID$IDs <- query\n\t\tresult = FindOverlap (convertedID,allGeneInfo(), input$selectGO3,input$selectOrg,1) }\n\n\tif( dim(result)[2] ==1) next;   # result could be NULL\n\tresult$Genes = toupper(letters)[i]\n\tif (pp==0 ) { results <- result; pp <- 1;} else  results <- rbind(results,result)\n\t}\n\tif( pp == 0) return( as.data.frame(\"No enrichment found.\") )\n\tresults= results[,c(5,1,2,4)]\n\tcolnames(results)= c(\"Cluster\",\"FDR\",\"Genes\",\"Pathways\")\n\tminFDR = 0.01\n\tif(min(results$FDR) > minFDR ) results = as.data.frame(\"No signficant enrichment found.\") else\n\tresults = results[which(results$FDR < minFDR),]\n\tincProgress(1, detail = paste(\"Done\"))\n\t}) #progress\n\tif( dim(results)[2] ==1)  return ( as.matrix(\"No significant enrichment.\") )\n\tcolnames(results)[2] = \"adj.Pval\"\n\tresults$Genes <- as.character(results$Genes)\n\tresults$Cluster[which( duplicated(results$Cluster) ) ] <- \"\"\n\tresults\n  }, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\noutput$KmeansPromoter <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectGO3; tem = input$radioPromoterKmeans; tem=input$nGenesKNN; tem=input$nClusters\n\tif( is.null(input$selectGO3 ) ) return (NULL)\n\tif( is.null(limma()$results) ) return(NULL)\n\n\tisolate({\n   \twithProgress(message=\"Promoter analysis\", {\n\tx <- convertedData()\n\t#x <- readData()\n\t#par(mfrow=c(2,1))\n\tn=input$nGenesKNN\n\t# if(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\n\tx=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\t#x = 100* x / apply(x,1,sum)  # this is causing problem??????\n\t#x = x - apply(x,1,mean)  # this is causing problem??????\n\t#colnames(x) = gsub(\"_.*\",\"\",colnames(x))\n\tset.seed(2)\n\t# determining number of clusters\n\tk=input$nClusters\n\tcl = kmeans(x,k,iter.max = 50)\n\n\thc <- hclust2(dist2(cl$centers-apply(cl$centers,1,mean) )  )# perform cluster for the reordering of samples\n\ttem = match(cl$cluster,hc$order) #  new order\n\tx = x[order(tem),]\n\tbar = sort(tem)\n\n\tresults1 <- NULL; result <- NULL\n\tpp<- 0\n\tfor( i in 1:k ) {\n\tincProgress(1/k, , detail = paste(\"Cluster\",toupper(letters)[i]) )\n\tquery = rownames(x)[which(bar == i)]\n\n\tconvertedID = convertID(query,input$selectOrg, input$selectGO2 );#\"gmax_eg_gene\"\n\tresult <- promoter( convertedID,input$selectOrg,input$radioPromoterKmeans )\n\n\tif( is.null(result)  ) next;   # result could be NULL\n\tif(  dim(result)[2] ==1) next;\n\tresult$List = toupper(letters)[i]\n\tif (pp==0 ) { results1 <- result; pp <- 1 } else  { results1 = rbind(results1,result) }\n\t}\n\n\tincProgress(1, detail = paste(\"Done\"))\n\t}) #progress\n\n\tif( is.null(results1) ) {as.data.frame(\"No significant motif enrichment found.\")} else {\n\t\tresults1[ duplicated (results1[,4] ),4 ] <- \"\"\n\t  results1[,c(4,1:3,5)]\n\t  }\n\t})\n  }, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\n# old heatmap.2 plot, replaced with plotly\noutput$heatmap1 <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    x <- readData()$data   # x = read.csv(\"expression1.csv\")\n\twithProgress(message=\"Reading and pre-processing \", {\n\tn=input$nGenes\n\tif(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\t# this will cutoff very large values, which could skew the color\n\tx=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\tcutoff = median(unlist(x)) + 4*sd (unlist(x))\n\tx[x>cutoff] <- cutoff\n\tcutoff = median(unlist(x)) - 4*sd (unlist(x))\n\tx[x< cutoff] <- cutoff\n\n    groups = detectGroups(colnames(x) )\n\tgroups.colors = rainbow(length(unique(groups) ) )\n\n\t#http://stackoverflow.com/questions/15351575/moving-color-key-in-r-heatmap-2-function-of-gplots-package\n\tlmat = rbind(c(5,4),c(0,1),c(3,2))\n\tlwid = c(1.5,6)\n\tlhei = c(1,.2,8)\n\n\tif( n>110)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F\n\t,ColSideColors=groups.colors[ as.factor(groups)]\n\t,labRow=\"\"\n\t,margins=c(10,0)\n\t,srtCol=45\n\t,lmat = lmat, lwid = lwid, lhei = lhei\n\t)\n\n\tif( n<=110)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F,\n\t#,labRow=labRow\n\t,ColSideColors=groups.colors[ groups]\n\t,margins=c(10,12)\n\t,cexRow=1\n\t,srtCol=45\n\t,lmat = lmat, lwid = lwid, lhei = lhei\n\t)\n\tincProgress(1,\"Done\")\n\t})\n  }, height = 800, width = 400)\n\noutput$heatmap <- renderPlotly({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n   # x <- readData()$data   # x = read.csv(\"expression1.csv\")\n    x <- convertedData()\n\twithProgress(message=\"Rendering heatmap \", {\n\tn=input$nGenes\n\tif(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\t# this will cutoff very large values, which could skew the color\n\tx=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\tcutoff = median(unlist(x)) + 3*sd (unlist(x))\n\tx[x>cutoff] <- cutoff\n\tcutoff = median(unlist(x)) - 3*sd (unlist(x))\n\tx[x< cutoff] <- cutoff\n\n\t# adding gene symbol\n\tix <- match( rownames(x), allGeneInfo()[,1])\n\tgeneSymbols <- as.character( allGeneInfo()$symbol)[ix]\n\t# if missing or duplicated, use Ensembl ID\n\tix <- which(nchar( geneSymbols) <=1 | duplicated(geneSymbols ) );\tgeneSymbols[ ix ] <- rownames(x)[ix]\n\trownames( x) = geneSymbols;\n\n\tincProgress(1/2, \"Clustering of genes\")\n\tclust <- x %>%\n\t  dist2() %>%\n\t  hclust2()\n\n\t# Get order\n\tord <- clust$order\n\n\t# Re-arrange based on order\n\tdf <- t( x[ord,] )%>%\n\t   melt()\n\n\tcolnames(df)[1:2] <- c(\"X\",\"Y\")\n\n\tp <- df %>%\n\t  ggplot(aes(X, Y, fill = value)) +\n\t\t   geom_tile()+ scale_fill_gradient2(low = \"green\", mid = \"black\",high = \"red\") +\n\t\t   theme(axis.title.y=element_blank(),   # remove y labels\n\t\t   # axis.text.y=element_blank(),  # keep gene names for zooming\n\t\t\taxis.ticks.y=element_blank(),\n\t\t\taxis.title.x=element_blank()) +\n\t\t\ttheme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\t\tincProgress(1,\"Done\")\n\tggplotly(p) %>%\n\t\tlayout(margin = list(b = 100,l=200))  # prevent cutoff of sample names\n\n\t})\n  })\n\nheatmapData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    x <- readData()$data\n\tgeneSD = apply(x,1,sd)\n\tx = x[order(-geneSD),]\n\n\tn=input$nGenes\n\tif(n>6000) n = 6000 # max\n\tif(n>dim(x)[1]) n = dim(x)[1] # max\tas data\n\t# this will cutoff very large values, which could skew the color\n\tx1 = x[1:n,]\n\tx=as.matrix(x[1:n,])-apply(x[1:n,],1,mean)\n\tcutoff = median(unlist(x)) + 3*sd (unlist(x))\n\tx[x>cutoff] <- cutoff\n\tcutoff = median(unlist(x)) - 3*sd (unlist(x))\n\tx[x< cutoff] <- cutoff\n\n\tgroups = detectGroups(colnames(x) )\n\tgroups.colors = rainbow(length(unique(groups) ) )\n\n\tpdf(file=NULL,width =700, height =700)\n\thy <- heatmap.2(x, distfun = dist2,hclustfun=hclust2,#labRow=\"\",labCol=\"\",\n\tdensity.info=\"none\", trace=\"none\", scale=\"none\")\n    dev.off()\n\n\t# if not new species, add gene symbol\n\tif( input$selectOrg != \"NEW\") {\n\t\tx1 <- x1[ rev( hy$rowInd),hy$colInd]\n\t\t# add gene symbol\n\t\tix = match( rownames(x1), allGeneInfo()[,1])\n\t\tx1 <- cbind(as.character( allGeneInfo()$symbol)[ix],x1)\n\t}\n\treturn( x1 )\n\n\n  })\n\noutput$downloadData <- downloadHandler(\n     filename = function() {\"heatmap.csv\"},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(heatmapData(), file)\n\t    }\n  )\n\noutput$debug <- renderTable({\n      if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\t  tem = input$selectOrg; tem = input$lowFilter ; tem = input$transform\n\tx <- convertedData()\n\t#tem = GeneSets()\n\n\treturn( as.data.frame (x[1:20,] ))\n\t},include.rownames=TRUE)\n\n\t    # this updates geneset categories based on species and file\n\noutput$selectGO1 <- renderUI({\n\t  tem = input$selectOrg\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectGO\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All available gene sets\" = \"All\", \"GO Biological Process\" = \"GOBP\",\"GO Molecular Function\" = \"GOMF\",\"GO Cellular Component\" = \"GOCC\",\n                                \"KEGG metabolic pathways\" = \"KEGG\"), selected = \"GOBP\")  }\t else {\n\n\t  selectInput(\"selectGO\", label=NULL,choices=gmtCategory(converted(), convertedData(), input$selectOrg,input$gmtFile)\n\t     ,selected = \"GOBP\" )   }\n\t})\n\noutput$selectGO2 <- renderUI({\n\t  tem = input$selectOrg\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectGO2\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All available gene sets\" = \"All\", \"GO Biological Process\" = \"GOBP\",\"GO Molecular Function\" = \"GOMF\",\"GO Cellular Component\" = \"GOCC\",\n                                \"KEGG metabolic pathways\" = \"KEGG\"), selected = \"GOBP\")  }\t else {\n\n\t  selectInput(\"selectGO2\", label=NULL,choices=gmtCategory(converted(), convertedData(), input$selectOrg,input$gmtFile)\n\t     ,selected = \"GOBP\" )   }\n\t})\n\noutput$selectGO3 <- renderUI({\n\t  tem = input$selectOrg\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectGO3\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All available gene sets\" = \"All\", \"GO Biological Process\" = \"GOBP\",\"GO Molecular Function\" = \"GOMF\",\"GO Cellular Component\" = \"GOCC\",\n                                \"KEGG metabolic pathways\" = \"KEGG\"), selected = \"GOBP\")  }\t else {\n\n\t  selectInput(\"selectGO3\", label=NULL,choices=gmtCategory(converted(), convertedData(), input$selectOrg,input$gmtFile)\n\t     ,selected = \"GOBP\" )   }\n\t})\n\noutput$PGSEAplot <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO;\t\ttem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tif(is.null(input$selectGO ) ) return (NULL)\n\tif(input$selectGO == \"ID not recognized!\" ) return( NULL)\n\tisolate({\n\twithProgress(message=\"Running pathway analysis\", {\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tgenes = convertedData()\nif (is.null(input$selectContrast1 ) ) return(NULL)\n\tincProgress(1/4,\"Retrieving gene sets\")\n\tgmt = GeneSets()\n\tincProgress(2/4,\"Runing PGSEA.\")\n\t#if(0){\n\tiz= match( detectGroups(colnames(genes)), unlist(strsplit( input$selectContrast1, \"-\"))\t  )\n    iz = which(!is.na(iz))\n\tif (grepl(\"Diff:\",input$selectContrast1) == 1) iz=1:(dim(genes)[2])\n\tgenes = genes[,iz]\n\t#}\n\tsubtype = detectGroups(colnames(genes ))\n    if(length( GeneSets() )  == 0)  { plot.new(); text(0.5,0.5, \"No gene sets!\")} else {\n\tresult = PGSEApathway(converted(),genes, input$selectOrg,input$selectGO,\n\t             GeneSets(),  myrange, input$pathwayPvalCutoff, input$nPathwayShow \t)\n\n\tif( is.null(result$pg3) ) { plot.new(); text(0.5,1, \"No significant pathway found!\")} else\n\tsmcPlot(result$pg3,factor(subtype),scale = c(-max(result$pg3), max(result$pg3)),\n\tshow.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5, main=\"Pathway Analysis:PGSEA\")\n    }\n\n\t})\n\t})\n    }, height = 800, width = 500)\n\noutput$PGSEAplotAllSamples <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tif(is.null(input$selectGO ) ) return (NULL)\n\tif(input$selectGO == \"ID not recognized!\" ) return( NULL)\n\tisolate({\n\twithProgress(message=\"Running pathway analysis\", {\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tgenes = convertedData()\nif (is.null(input$selectContrast1 ) ) return(NULL)\n\tincProgress(1/4,\"Retrieving gene sets\")\n\tgmt = GeneSets()\n\tincProgress(2/8, \"Runing PGSEA\")\n\tsubtype = detectGroups(colnames(genes ))\n    if(length( GeneSets() )  == 0)  { plot.new(); text(0,1, \"No gene sets!\")} else {\n\tresult = PGSEApathway(converted(),genes, input$selectOrg,input$selectGO,\n\t             GeneSets(),  myrange, input$pathwayPvalCutoff, input$nPathwayShow \t)\n\n\tif( is.null(result$pg3) ) { plot.new(); text(0.5,1, \"No significant pathway found!\")} else\n\tsmcPlot(result$pg3,factor(subtype),scale = c(-max(result$pg3), max(result$pg3)),\n\tshow.grid = T, margins = c(3,1, 13, 23), col = .rwb,cex.lab=0.5, main=\"Pathway Analysis:PGSEA\")\n    }\n\n\t})\n\t})\n    }, height = 800, width = 500)\n\noutput$gagePathway <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO;\ttem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tisolate({\n\tgagePathwayData()\n\t})\n  },digits=0,align=\"l\",include.rownames=FALSE,striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\ngagePathwayData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO\n\ttem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tif(is.null(input$selectGO ) ) return (NULL)\n\tif(input$selectGO == \"ID not recognized!\" ) return( as.data.frame(\"Gene ID not recognized.\" ))\n\tisolate({\n\twithProgress(message=\"Running pathway analysis using GAGE\", {\n\tif (is.null(input$selectContrast1 ) ) return(NULL)\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tnoSig = as.data.frame(\"No significant pathway found.\")\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast1, names(top))\n\t  if( is.na(ix)) return (noSig)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (noSig)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t  incProgress(1/4,\"Retrieving gene sets\")\n\t  gmt = GeneSets()\n      if(length( GeneSets() )  == 0)  { return(as.data.frame(\"No gene set found!\"))}\n\t  #converted = convertID(rownames(top1),input$selectOrg)\n\t  #\n\t   #gmt = readGeneSets(converted, top1, input$selectGO, input$selectOrg, myrange )\n     # cat(\"Sets\",length(gmt))\n\t incProgress(2/4,\"Runing GAGE\")\n\t fold = top1[,1]; names(fold) <- rownames(top1)\n\n\t if(input$absoluteFold) fold <- abs(fold)\n\t paths <- gage(fold, gsets = gmt, ref = NULL, samp = NULL)\n\n\t  paths <-  rbind(paths$greater,paths$less)\n\t # write.csv(paths,\"tem.csv\")\n\t # cat( dim(paths) )\n\t  if(dim(paths)[1] < 1 | dim(paths)[2]< 6 ) return( noSig )\n\t  top1 <- paths[,c('stat.mean','set.size','q.val')]\n\t  colnames(top1)= c(\"statistic\",\"Genes\",\"adj.Pval\")\n\t  top1 <- top1[order(top1[,3]) ,]\n\t  if ( length( which( top1[,3] <=  input$pathwayPvalCutoff   ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1[,3] <=  input$pathwayPvalCutoff ) ,,drop=FALSE]\n\t  if(dim(top1)[1] > input$nPathwayShow )\n\t     top1 <- top1[1:input$nPathwayShow, ,drop=FALSE]\n\n\t\ttop1 <- as.data.frame(top1)\n\t\ttop1 <- cbind(rep( input$selectContrast1, dim(top1)[1]),row.names(top1), top1);\n\t\ttop1$statistic <- as.character( round(as.numeric(top1$statistic),4));\n\t\ttop1$adj.Pval <- sprintf(\"%-2.1e\",as.numeric(top1$adj.Pval) )\n\t\ttop1[,2] <- as.character(top1[,2]);top1[,1] <- as.character(top1[,1])\n\t\tcolnames(top1)[1] <- \"Direction\"\n\t\tif(input$pathwayMethod == 1 ) p.m <- \"GAGE\"\n\t\telse if(input$pathwayMethod == 2 ) p.m <- \"PGSEA\"\n\t\telse if(input$pathwayMethod == 3 ) p.m <- \"GSEA\"\n\t\telse if(input$pathwayMethod == 4 ) p.m <- \"PGSEA_All\"\n\t\telse if(input$pathwayMethod == 5 ) p.m <- \"ReactomePA\"\n\t\tcolnames(top1)[2] <- paste(p.m,\" analysis:\", gsub(\"-\",\" vs \",input$selectContrast1 ) )\n\t\ttop1[ which( top1[,3] >0),1 ] <- gsub(\"-\",\" > \",input$selectContrast1 )\n\t\ttop1[ which( top1[,3] <0),1 ] <- gsub(\"-\",\" < \",input$selectContrast1 )\n\t\ttop1 <- top1[order( top1[,1], -abs(as.numeric( top1[,3]) ) ) ,]\n\t\ttop1[ duplicated (top1[,1] ),1 ] <- \"\"\n\t\t#write.csv(top1,\"tem.csv\")\n\t  return( top1)\n\t}) })\n  })\n\noutput$fgseaPathway <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO; tem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tisolate({\n\tfgseaPathwayData()\n\t})\n  },digits=0,align=\"l\",include.rownames=FALSE,striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\nfgseaPathwayData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO; tem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tif(is.null(input$selectGO ) ) return (NULL)\n\tif(input$selectGO == \"ID not recognized!\" ) return( as.data.frame(\"Gene ID not recognized.\" ))\n\tisolate({\n\twithProgress(message=\"Running pathway analysis using GAGE\", {\n\tif (is.null(input$selectContrast1 ) ) return(NULL)\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tnoSig = as.data.frame(\"No significant pathway found.\")\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast1, names(top))\n\t  if( is.na(ix)) return (noSig)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (noSig)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t  incProgress(1/4,\"Retrieving gene sets\")\n\t  gmt = GeneSets()\n     if(length( GeneSets() )  == 0)  { return(as.data.frame(\"No gene set found!\"))}\n\n\t  #converted = convertID(rownames(top1),input$selectOrg)\n\t  #\n\t   #gmt = readGeneSets(converted, top1, input$selectGO, input$selectOrg, myrange )\n     # cat(\"Sets\",length(gmt))\n\t incProgress(2/4,\"Runing GSEA using the fgsea package.\")\n\t fold = top1[,1]; names(fold) <- rownames(top1)\n\t if(input$absoluteFold) fold <- abs(fold) # use absolute value of fold change, disregard direction\n\t paths <- fgsea(pathways = gmt,\n                  stats = fold,\n                  minSize=input$minSetSize,\n                  maxSize=input$maxSetSize,\n                  nperm=5000)\n\t # paths <-  rbind(paths$greater,paths$less)\n\t  if(dim(paths)[1] < 1  ) return( noSig )\n\t       paths <- as.data.frame(paths)\n       paths <- paths[order(-abs( paths[,5])) ,]  # sort by NES\n\t  # paths <- paths[order( paths[,3]) ,]  # sort by FDR\n\t  top1 <- paths[,c(1,5,7,3)]\n\t  # rownames(top1) <- paths[,1] #paste(1:dim(paths)[1],\": \",paths[,1],sep=\"\" )\n\t  colnames(top1)= c(\"Pathway\", \"NES\",\"Genes\",\"adj.Pval\")\n\n\t  if ( length( which( top1[,4] <=  input$pathwayPvalCutoff   ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1[,4] <=  input$pathwayPvalCutoff ) , ,drop=FALSE]\n\t  if(dim(top1)[1] > input$nPathwayShow )\n\t     top1 <- top1[1:input$nPathwayShow,,drop=FALSE]\n\t #top1 <- cbind(row.names(top1), top1); colnames(top1)[1] <-input$selectContrast1\n\t\ttop1 <- as.data.frame(top1)\n\t\ttop1 <- cbind(rep( input$selectContrast1, dim(top1)[1]), top1);\n\t\ttop1[,4] = as.character( round(as.numeric(top1[,4]),4));\n\t\ttop1$adj.Pval <- sprintf(\"%-2.1e\",as.numeric(top1$adj.Pval) )\n\t\ttop1[,1] <- as.character(top1[,1])\n\t\tcolnames(top1)[1] <- \"Direction\"\n\t\tif(input$pathwayMethod == 1 ) p.m <- \"GAGE\"\n\t\telse if(input$pathwayMethod == 2 ) p.m <- \"PGSEA\"\n\t\telse if(input$pathwayMethod == 3 ) p.m <- \"GSEA\"\n\t\telse if(input$pathwayMethod == 4 ) p.m <- \"PGSEA_All\"\n\t\telse if(input$pathwayMethod == 5 ) p.m <- \"ReactomePA\"\n\t\tcolnames(top1)[2] <- paste(p.m,\" analysis:\", gsub(\"-\",\" vs \",input$selectContrast1 ) )\n\t\ttop1[ which( as.numeric( top1[,3]) >0),1 ] <- gsub(\"-\",\" > \",input$selectContrast1 )\n\t\ttop1[ which( as.numeric( top1[,3]) <0),1 ] <- gsub(\"-\",\" < \",input$selectContrast1 )\n\t\ttop1 <- top1[order( top1[,1], -abs(as.numeric( top1[,3]) ) ) ,]\n\t\ttop1[ duplicated (top1[,1] ),1 ] <- \"\"\n\t    top1[,3] = as.character( round(as.numeric(top1[,3]),4));\n\t return( top1)\n\t}) })\n  })\n\nReactomePAPathwayData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO; tem = input$selectContrast1\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tif(is.null(input$selectGO ) ) return (NULL)\n\tif(input$selectGO == \"ID not recognized!\" ) return( as.data.frame(\"Gene ID not recognized.\" ))\n\tisolate({\n\twithProgress(message=\"Running pathway analysis using ReactomePA\", {\n\tif (is.null(input$selectContrast1 ) ) return(NULL)\n\n\tensemblSpecies <- c(\"hsapiens_gene_ensembl\",\"rnorvegicus_gene_ensembl\", \"mmusculus_gene_ensembl\",\n\t\t               \"celegans_gene_ensembl\",\"scerevisiae_gene_ensembl\", \"drerio_gene_ensembl\", \"dmelanogaster_gene_ensembl\")\n    ReactomePASpecies= c(\"human\", \"rat\", \"mouse\", \"celegans\", \"yeast\", \"zebrafish\", \"fly\" )\n    # cbind(ensemblSpecies,ReactomePASpecies)  # double check mapping\n\n\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tnoSig = as.data.frame(\"No significant pathway found.\")\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast1, names(top))\n\t  if( is.na(ix)) return (noSig)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (noSig)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t  incProgress(1/4,\"Retrieving gene sets\")\n\t  # gmt = GeneSets()\n\n\t  #converted = convertID(rownames(top1),input$selectOrg)\n\t  #\n\t   #gmt = readGeneSets(converted, top1, input$selectGO, input$selectOrg, myrange )\n     # cat(\"Sets\",length(gmt))\n\n\t fold = top1[,1]; names(fold) <- rownames(top1)\n\t if(input$absoluteFold) fold <- abs(fold) # use absolute value of fold change, disregard direction\n\n      incProgress(2/4,\"Convert to Entrez Gene ID\")\n      Species <- converted()$species[1,1]\n      ix <- match( Species,ensemblSpecies )\n\t  if(is.na(ix) ) return(as.data.frame(\"Species not coverted by ReactomePA package!\"))\n\n\t  fold <- convertEnsembl2Entrez (fold, Species)\n\t\t fold <- sort(fold,decreasing =T)\n\t  incProgress(3/4,\"Runing enrichment analysis using fgsea\")\n\t  paths <- gsePathway(fold, nPerm=5000, organism = ReactomePASpecies[ix],\n                minGSSize= input$minSetSize,\n\t\t\t\tmaxGSSize= input$maxSetSize,\n\t\t\t\tpvalueCutoff=0.5,\n                pAdjustMethod=\"BH\", verbose=FALSE)\n      paths <- as.data.frame(paths)\n\n\t  if(is.null(paths) ) return( noSig)\n\t  if(dim(paths)[1] ==0 ) return( noSig)\n\n\t # paths <-  rbind(paths$greater,paths$less)\n\t  if(dim(paths)[1] < 1  ) return( noSig )\n\t       paths <- as.data.frame(paths)\n       paths <- paths[order(-abs( paths[,5])) ,]  # sort by NES\n\t  # paths <- paths[order( paths[,3]) ,]  # sort by FDR\n\t  top1 <- paths[,c(2,5,3,7)]\n\t  # rownames(top1) <- paths[,1] #paste(1:dim(paths)[1],\": \",paths[,1],sep=\"\" )\n\t  colnames(top1)= c(\"Pathway\", \"NES\",\"Genes\",\"adj.Pval\")\n\n\t  if ( length( which( top1[,4] <=  input$pathwayPvalCutoff   ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1[,4] <=  input$pathwayPvalCutoff ) ,,drop=FALSE]\n\t  if(dim(top1)[1] > input$nPathwayShow )\n\t     top1 <- top1[1:input$nPathwayShow,,drop=FALSE]\n\t #top1 <- cbind(row.names(top1), top1); colnames(top1)[1] <-input$selectContrast1\n\t\ttop1 <- as.data.frame(top1)\n\t\ttop1 <- cbind(rep( input$selectContrast1, dim(top1)[1]), top1);\n\t\ttop1[,4] = as.character( round(as.numeric(top1[,4]),4));\n\t\ttop1$adj.Pval <- sprintf(\"%-2.1e\",as.numeric(top1$adj.Pval) )\n\t\ttop1[,1] <- as.character(top1[,1])\n\t\tcolnames(top1)[1] <- \"Direction\"\n\t\tif(input$pathwayMethod == 1 ) p.m <- \"GAGE\"\n\t\telse if(input$pathwayMethod == 2 ) p.m <- \"PGSEA\"\n\t\telse if(input$pathwayMethod == 3 ) p.m <- \"GSEA\"\n\t\telse if(input$pathwayMethod == 4 ) p.m <- \"PGSEA_All\"\n\t\telse if(input$pathwayMethod == 5 ) p.m <- \"ReactomePA\"\n\t\tcolnames(top1)[2] <- paste(p.m,\" analysis:\", gsub(\"-\",\" vs \",input$selectContrast1 ) )\n\t\ttop1[ which( as.numeric( top1[,3]) >0),1 ] <- gsub(\"-\",\" > \",input$selectContrast1 )\n\t\ttop1[ which( as.numeric( top1[,3]) <0),1 ] <- gsub(\"-\",\" < \",input$selectContrast1 )\n\t\ttop1 <- top1[order( top1[,1], -abs(as.numeric( top1[,3]) ) ) ,]\n\t\ttop1[ duplicated (top1[,1] ),1 ] <- \"\"\n\t  top1[,3] = as.character( round(as.numeric(top1[,3]),4));\n\t return( top1)\n\t}) })\n  })\n\noutput$ReactomePAPathway <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO; tem = input$selectContrast1\n    tem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\tisolate({\n\tReactomePAPathwayData()\n\t})\n  },digits=0,align=\"l\",include.rownames=FALSE,striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\nPGSEAplot.data <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\n\tisolate({\n\twithProgress(message=\"Running pathway analysis\", {\n\tmyrange = c(input$minSetSize, input$maxSetSize)\n\tgenes = convertedData()\nif (is.null(input$selectContrast1 ) ) return(NULL)\n\tgmt = GeneSets()\n\tincProgress(2/8)\n\t#if(0){\n\tiz= match( detectGroups(colnames(genes)), unlist(strsplit( input$selectContrast1, \"-\"))\t  )\n    iz = which(!is.na(iz))\n\tif (grepl(\"Diff:\",input$selectContrast1) == 1) iz=1:(dim(genes)[2])\n\tgenes = genes[,iz]\n\t#}\n\tsubtype = detectGroups(colnames(genes ))\n    if(length( GeneSets() )  == 0)  { plot.new(); text(0,1, \"No gene sets!\")} else {\n\tresult = PGSEApathway(converted(),genes, input$selectOrg,input$selectGO,\n\t             GeneSets(),  myrange, input$pathwayPvalCutoff, input$nPathwayShow \t)\n\n\tif( is.null(result$pg3) ) { return(as.matrix(\"No significant pathway!\"))} else\n\t   return( result$pg3)\n    }\n\n\t})\n\t})\n    })\n\noutput$download.PGSEAplot.data <- downloadHandler(\n     filename = function() {\"PGSEA_pathway_anova.csv\"},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(PGSEAplot.data(), file)\n\t    }\n  )\n\noutput$listSigPathways <- renderUI({\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC\n\n      if (is.null(input$file1)&& input$goButton == 0 | is.null(gagePathwayData()))\n\n       { selectInput(\"sigPathways\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All\" = \"All\"), selected = \"All\")  }\t else {\n\t\tchoices <- \"All\"  # default, sometimes these methods returns \"No significant pathway found\"\n\t\tif( input$pathwayMethod == 1) { if(!is.null(gagePathwayData())) if(dim(gagePathwayData())[2] >1) choices <- gagePathwayData()[,2] }\n\t\telse if( input$pathwayMethod == 3) { if(!is.null(fgseaPathwayData())) if(dim(fgseaPathwayData())[2] >1) choices <- fgseaPathwayData()[,2] }\n\t\telse if( input$pathwayMethod == 5) { if(!is.null(ReactomePAPathwayData())) if(dim(ReactomePAPathwayData())[2] >1) choices <- ReactomePAPathwayData()[,2] }\n\t\tselectInput(\"sigPathways\", label=\"Select a pathway to show expression pattern of related genes:\",choices=choices)\n\t        }\n\t})\n\nselectedPathwayData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\ttem = input$sigPathways;\n\tif(is.null(gagePathwayData() ) ) return(NULL)\n\tif(is.null( input$sigPathways))  return (NULL)\n\t#cat(input$sigPathways)\n    isolate({\n\twithProgress (message=\"Retrieving genes\",{\n    if(input$sigPathways == \"All\") return (NULL)\n\tix <- which(names(GeneSets() ) == input$sigPathways   ) # find the gene set\n\tif(length(ix) == 0 ) return(NULL)\n    genes <- GeneSets()[[ix]] # retrieve genes\n\t# genes <- pathwayGenes(input$sigPathways,converted(), input$selectGO1,input$selectOrg )\n\tincProgress(1/2,\"Merging data\")\n\n    x <-  convertedData()[which(rownames(convertedData()) %in% genes) ,]\n\tif( input$selectOrg != \"NEW\") {\n\tix = match( rownames(x), allGeneInfo()[,1])\n\trownames(x) <- paste(rownames(x),\":\", as.character( allGeneInfo()$symbol)[ix]) }\n\n\treturn( x )\n\n     }) })\n})\n\noutput$downloadSelectedPathwayData <- downloadHandler(\n    # filename = function() {\"Selected_Pathway_detail.csv\"},\n\t  filename = function() {paste(input$selectContrast1,\"(\",input$sigPathways,\")\",\".csv\",sep=\"\")},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(selectedPathwayData(), file)\n\t    }\n  )\n\noutput$selectedPathwayHeatmap <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\ttem = input$sigPathways;\n\tif(is.null(gagePathwayData() ) ) return(NULL)\n\tif(is.null( input$sigPathways))  return (NULL)\n\tif( is.null(selectedPathwayData()) ) return(NULL)\n\t# cat(input$sigPathways)\n\n    isolate({\n\tx = selectedPathwayData()\n\tif(dim(x)[1]<=2 | dim(x)[2]<=2 ) return(NULL)\n\tgroups = detectGroups(colnames(x))\n\twithProgress(message=\"Generating heatmap\",{\n\t# this will cutoff very large values, which could skew the color\n\tx=as.matrix(x)-apply(as.matrix(x),1,mean)\n\tcutoff = median(unlist(x)) + 3*sd (unlist(x))\n\tx[x>cutoff] <- cutoff\n\tcutoff = median(unlist(x)) - 3*sd (unlist(x))\n\tx[x< cutoff] <- cutoff\n\n\tlmat = rbind(c(5,4),c(0,1),c(3,2))\n\tlwid = c(1.5,6)\n\tlhei = c(1,.2,8)\n\n\tif( dim(x)[1]>100)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F\n\t,ColSideColors=mycolors[ groups]\n\t,labRow=\"\"\n\t,margins=c(10,0)\n\t,srtCol=45\n\t,lmat = lmat, lwid = lwid, lhei = lhei\n\t#,main =\"Title\"\n\t)\n\n\tif( dim(x)[1]<=100)\n\theatmap.2(x, distfun = dist2,hclustfun=hclust2,\n\t col=greenred(75), density.info=\"none\", trace=\"none\", scale=\"none\", keysize=.5\n\t,key=T, symkey=F,\n\t#,labRow=labRow\n\t\t,ColSideColors=mycolors[ groups]\n\t,margins=c(10,12)\n\t,cexRow=1.5\n\t,srtCol=45\n\t,lmat = lmat, lwid = lwid, lhei = lhei\n\t#,main =\"Title\"\n\t)\n\tincProgress(1,\"Done\")\n    })\n\t})\n}, height = 800, width = 400)\n\noutput$KeggImage <- renderImage({\n   # First generate a blank image. Otherse return(NULL) gives us errors.\n    outfile <- tempfile(fileext='.png')\n    png(outfile, width=400, height=300)\n    frame()\n\tdev.off()\n    blank <- list(src = outfile,\n         contentType = 'image/png',\n         width = 400,\n         height = 300,\n         alt = \" \")\n    if (is.null(input$file1)&& input$goButton == 0)   return(blank)\n\n\ttem = input$selectOrg ; #tem = input$listComparisonsPathway\n\ttem = input$selectGO\n\ttem = input$selectContrast\n\ttem = input$minSetSize; tem = input$maxSetSize; tem=input$pathwayPvalCutoff;\n\ttem=input$nPathwayShow; tem=input$absoluteFold\n\ttem = input$sigPathways;\n\tif(is.null( input$selectGO ) ) return(blank)\n\tif(input$selectGO != \"KEGG\") return(blank)\n\tif(is.null(gagePathwayData() ) ) return(blank)\n\tif(is.null( input$sigPathways))  return (blank)\n\t# if( is.null(selectedPathwayData()) ) return(blank)\n\n\tisolate({\n\twithProgress(message=\"Rendering KEGG pathway plot\", {\n\n\tif (is.null(input$selectContrast1 ) ) return(blank)\n\n\tif(input$sigPathways == \"All\") return (blank)\n\n\tif( length(limma()$topGenes) == 0 ) return(blank)\n\n\t# get fold change\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast1, names(top))\n\t  if( is.na(ix)) return (blank)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (blank)\n\t # cat(\"here5\")\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n      Species <- converted()$species[1,1]\n\n\t fold = top1[,1]; names(fold) <- rownames(top1)\n\t fold <- convertEnsembl2Entrez(fold,Species)\n\n     keggSpecies <- as.character( keggSpeciesID[which(keggSpeciesID[,1] == Species),3] )\n\n     if(nchar( keggSpecies) <=2 ) return(blank) # not in KEGG\n\n\n\t # kegg pathway id\n\tincProgress(1/2, \"Download pathway graph from KEGG.\")\n\t#incProgress(1/2, outfile)\n\tpathID = keggPathwayID(input$sigPathways, Species, \"KEGG\",input$selectOrg)\n\t#cat(\"here5  \",keggSpecies, \" \",Species,\" \",input$sigPathways, \"pathID:\",pathID,\"End\", fold[1:5],names(fold)[1:5],\"\\n\")\n\t#cat(\"pathway:\",is.na(input$sigPathways))\n\t#cat(\"\\n\",fold[1:5],\"\\n\",keggSpecies,\"\\n\",pathID)\n    if(is.null(pathID) ) return(blank) # kegg pathway id not found.\n\trandomString <- gsub(\".*file\",\"\",tempfile())\n\t tempFolder <- tempdir() # tempFolder = \"temp\";\n\toutfile <- paste( tempFolder,\"/\",pathID,\".\",randomString,\".png\",sep=\"\")\n\twd = getwd()\n\tsetwd(tempFolder)\n\n\t#pv.out <- mypathview(gene.data = fold, pathway.id = pathID, kegg.dir = tempFolder,  out.suffix = randomString, species = keggSpecies, kegg.native=TRUE)\n\tpv.out <- pathview(gene.data = fold, pathway.id = pathID, out.suffix = randomString, species = keggSpecies, kegg.native=TRUE)\n    setwd(wd)\n    # Return a list containing the filename\n    list(src = outfile,\n         contentType = 'image/png',\n       width = \"200%\",\n        height = \"200%\",\n         alt = \"KEGG pathway image.\")\n\t\t})\n\t})\n  }, deleteFile = TRUE)\n\nlimma <- reactive({\n  if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$CountsDEGMethod; tem = input$countsLogStart\n\tisolate({\n\twithProgress(message=\"Identifying Differentially expressed genes\", {\n\tif(input$dataFileFormat == 1 ) {  # if count data\n\t\t if(input$CountsDEGMethod == 3 )   # if DESeq2 method\n\t\t  # rawCounts = read.csv(\"exampleData/airway_GSE52778.csv\", row.names=1)\n\t\t # res =DEG.DESeq2(rawCounts, .05, 2)\n\t\t  # res1 =DEG.limma(rawCounts, .1, 1.5,rawCounts, 2,3)\n\t\t\treturn( DEG.DESeq2(readData()$rawCounts,input$limmaPval, input$limmaFC)  )\n\t\tif(input$CountsDEGMethod < 3 )    # voom or limma-trend\n\t\t\treturn( DEG.limma(convertedData(), input$limmaPval, input$limmaFC,readData()$rawCounts, input$CountsDEGMethod,priorCounts=input$countsLogStart,input$dataFileFormat) )\n\t} else { # normalized data\n\t return( DEG.limma(convertedData(), input$limmaPval, input$limmaFC,readData()$rawCounts, input$CountsDEGMethod,priorCounts=input$countsLogStart,input$dataFileFormat) )\n\t}\n\n\n\t})\n\t})\n\t})\n\noutput$text.limma <- renderText({\n      if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n \ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC\n\t  limma()$Exp.type\n\n\t})\n\noutput$vennPlot <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC\n\tisolate({\n\n\tresults = limma()$results\n\tif(dim(results)[2] >5) results <- results[,1:5]\n\tvennDiagram(results,circle.col=rainbow(5))\n\n\n\t})\n    }, height = 600, width = 600)\n\noutput$listComparisons <- renderUI({\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC\n\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectContrast\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All\" = \"All\"), selected = \"All\")  }\t else {\n\t  selectInput(\"selectContrast\", label=\"Select a comparison to examine. A-B means A vs. B.\",choices=limma()$comparisons\n\t     )   }\n\t})\n\noutput$listComparisonsPathway <- renderUI({\n\ttem = input$selectOrg\n\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectContrast1\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All\" = \"All\"), selected = \"All\")  }\t else {\n\t  selectInput(\"selectContrast1\", label=\"Select a comparison to analyze:\",choices=limma()$comparisons\n\t     )   }\n\t})\n\noutput$listComparisonsGenome <- renderUI({\n\ttem = input$selectOrg\n\n      if (is.null(input$file1)&& input$goButton == 0 )\n       { selectInput(\"selectContrast1\", label = NULL, # h6(\"Funtional Category\"),\n                  choices = list(\"All\" = \"All\"), selected = \"All\")  }\t else {\n\t  selectInput(\"selectContrast2\", label=\"Select a comparison to analyze:\",choices=limma()$comparisons\n\t     )   }\n\t})\n\nDEG.data <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC;\n\t\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tisolate({\n\t  genes = limma()$results\n\t  genes = as.data.frame( genes[which( rowSums(genes) != 0 ),] )\n\t  colnames(genes) = colnames( limma()$results )\n\t  genes = merge(genes,convertedData(), by='row.names')\n\t  colnames(genes)[1] = \"1: upregulation, -1: downregulation\"\n\t  \t# add gene symbol\n\tix = match( genes[,1], allGeneInfo()[,1])\n\tgenes <- cbind(as.character( allGeneInfo()$symbol)[ix],genes)\n\tcolnames(genes)[1] = \"Symbol\"\n\tgenes <- genes[,c(2,1,3:dim(genes)[2]) ]\n\treturn(genes)\n\t})\n    })\n\noutput$selectedHeatmap <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast;\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\twithProgress(message=\"Generating heatmap\", {\n\tif( is.null(input$selectContrast)) return(NULL)\n\tif( is.null(limma()$results)) return(NULL)\n\tisolate({\n\t  genes = limma()$results\n\t  if( is.null(genes) ) return(NULL)\n\t  ix = match(input$selectContrast, colnames(genes))\n\t  if(is.null(ix)) reutn(NULL); if(is.na(ix)) return (NULL)\n\t  if( sum(abs(genes[,ix] )  ) <= 1 ) return(NULL) # no significant genes for this comparison\n\t  query = rownames(genes)[which(genes[,ix] != 0)]\n      iy = match(query, rownames(convertedData()  ) )\n\t iz= match( detectGroups(colnames(convertedData())), unlist(strsplit( input$selectContrast, \"-\"))\t  )\n     iz = which(!is.na(iz))\n\t if (grepl(\"Diff:\",input$selectContrast) == 1) iz=1:(dim(convertedData())[2]) # if it is factor design use all samples\n\t genes = convertedData()[iy,iz]\n\t groups = detectGroups(colnames(genes) )\n\t N1 = sum(groups == groups[1] ) # number of samples in type above\n\t fc = rowMeans(genes[,1:N1])-rowMeans(genes[,(N1+1):length(groups)])\n\t genes = genes[order(fc),]\n\t fc = sort(fc)\n\t bar = (fc>0 )+1\n\t incProgress(1/2 )\n \t myheatmap2( genes,bar,200 )\n\t incProgress(1, detail = paste(\"Done\"))\n\n\t })\n\t})\n\n    }, height = 400, width = 500)\n\nselectedHeatmap.data <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast;\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tif( is.null(input$selectContrast)) return(NULL)\n\tif( is.null(limma()$results) ) return(NULL)\n\tisolate({\n\t  genes <- limma()$results\n\t  if( is.null(genes) ) return(NULL)\n\t  ix = match(input$selectContrast, colnames(genes))\n\t  if(is.null(ix)) return(NULL)\n\t  if(is.na(ix)) return(NULL)\n\t  if( sum(abs(genes[,ix] )  ) <= 1 ) return(NULL) # no significant genes for this comparison\n\t  if(dim(genes)[2] < ix ) return(NULL)\n\t  query = rownames(genes)[which(genes[,ix] != 0)]\n\t  if(length(query) == 0) return(NULL)\n      iy = match(query, rownames(convertedData()  ) )\n\n     iz= match( detectGroups(colnames(convertedData())), unlist(strsplit( input$selectContrast, \"-\"))\t  )\n     iz = which(!is.na(iz))\n\t if (grepl(\"Diff:\",input$selectContrast) == 1) iz=1:(dim(convertedData())[2]) # if it is factor design use all samples\n\t genes = convertedData()[iy,iz]\n\t groups = detectGroups(colnames(genes) )\n\t N1 = sum(groups == groups[1] ) # number of samples in type above\n\t fc = rowMeans(genes[,1:N1])-rowMeans(genes[,(N1+1):length(groups)])\n\t genes = genes[order(fc),]\n \t return(genes)\n\t})\n    })\n\noutput$download.selectedHeatmap.data <- downloadHandler(\n     filename = function() {paste(\"Diff_genes_heatmap_\",input$selectContrast,\".csv\",sep=\"\")},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(geneListDataExport(), file, row.names=FALSE)\n\t    }\n  )\n\noutput$download.DEG.data <- downloadHandler(\n     filename = function() {\"Diff_expression_all_comparisons.csv\"},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(DEG.data(), file,row.names=FALSE)\n\t    }\n  )\n\noutput$geneList <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0  )   return(NULL)\n\t\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tnoSig = as.data.frame(\"No significant genes find!\")\n\tif( is.null(input$selectContrast) ) return(NULL)\n\tif( is.null( limma()$comparisons ) ) return(NULL) # if no significant genes found\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif( is.null( geneListData() ) ) return(NULL)\n\tif( dim(geneListData() )[1]> 50 )\n\t\treturn( geneListData()[1:50,] )\n\telse return( geneListData() )\n\n\n  },digits=2,align=\"l\",include.rownames=F,striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n  #, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T,include.rownames=TRUE)\n\ngeneListDataExport <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0  )   return(NULL)\n\t\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tnoSig = as.data.frame(\"No significant genes find!\")\n\tif( is.null(input$selectContrast) ) return(NULL)\n\tif( is.null( limma()$comparisons ) ) return(NULL) # if no significant genes found\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif( is.null( geneListData() ) ) return(NULL)\n\tif( input$selectOrg == \"NEW\" )\n\t\ttem <- merge(geneListData(), convertedData(), by.x = 'Top_Genes',by.y = 'row.names') else\n\ttem <- merge(geneListData(), convertedData(), by.x = 'Ensembl ID',by.y = 'row.names')\n\ttem <- tem[order( -sign(tem[,2] ), -abs(tem[,2])),]\n\ttem$Regulation = \"Up\"\n\ttem$Regulation[which(tem[,2]<0 )] <- \"Down\"\n\ttem <- tem[,c(dim(tem)[2],1:( dim(tem)[2]-1) )  ]\n\treturn( tem )\n\n  })\n  #, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T,include.rownames=TRUE)\n\ngeneListData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0  )   return(NULL)\n\t\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tnoSig = as.data.frame(\"No significant genes find!\")\n\tif( is.null(input$selectContrast) ) return(NULL)\n\tif( is.null( limma()$comparisons ) ) return(NULL) # if no significant genes found\n\tif( length(limma()$topGenes) == 0 ) return(noSig)\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast, names(top))\n\t  if( is.na(ix)) return (noSig)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (noSig)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t  #top1 = merge(top1,convertedData(), by='row.names')\n\t  #colnames(top1)[1] = \"Genes\"\n\t  top1 = top1[order(-abs(top1$Fold)) ,]\n\t  if ( length( which( top1$FDR <=  input$limmaPval  &  abs(top1$Fold)  >= log2(input$limmaFC) ) ) == 0 )\n\t    return( noSig)\n\t  top1 <- top1[which(top1$FDR <=  input$limmaPval ) ,]\n\t  top1 <- top1[which(abs(top1$Fold)  >= log2( input$limmaFC)) ,]\n\t  top1$Top_Genes <- rownames(top1)\n\t  top1 <- top1[,c(3,1,2)]\n\n\t  # if new species\n\t  if( input$selectGO2 == \"ID not recognized!\" | input$selectOrg == \"NEW\") return (top1);\n\n\t  #convertedID = convertID(top1[,1],input$selectOrg, \"GOBP\" );#\"gmax_eg_gene\"\n\t  # tem <- geneInfo(convertedID,input$selectOrg) #input$selectOrg ) ;\n\t #  tem <- geneInfo(converted(),input$selectOrg)\n\t  top1 <- merge(top1, allGeneInfo(), by.x =\"Top_Genes\", by.y=\"ensembl_gene_id\",all.x=T )\n\n      if ( sum( is.na(top1$band)) == dim(top1)[1] ) top1$chr = top1$chromosome_name else\n\t  \ttop1$chr = paste( top1$chromosome_name, top1$band,sep=\"\")\n\n\t  top1 <- top1[,c('Top_Genes','Fold','FDR','symbol','chr','gene_biotype')]\n\n\n\t#  ix = match(top1[,1], tem$ensembl_gene_id)\n\t # if( sum(is.na( tem$Symbol[ix]) ) != length(ix) )\n\t  # { top1 <- cbind(top1, tem$Symbol[ix]); colnames(top1)[4]= \"Symbol\" }\n\t  top1 = top1[order(-abs(as.numeric( top1$Fold))) ,]\n\t  top1$FDR <- sprintf(\"%-3.2e\",top1$FDR )\n\t  colnames(top1) <- c(\"Ensembl ID\", \"log2 Fold Change\", \"Adj.Pval\", \"Symbol\",\"Chr\",\"Type\")\n\t  if ( sum( is.na(top1$Symbol)) == dim(top1)[1] ) top1 <- top1[,-4]\n\n\t  return(top1)\n\n  })\n\noutput$volcanoPlot <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0  )   return(NULL)\n\t\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tif( is.null(input$selectContrast) ) return(NULL)\n\tif( is.null( limma()$comparisons ) ) return(NULL) # if no significant genes found\n\tif( length(limma()$topGenes) == 0 ) return(NULL)\n\tisolate({\n\twithProgress(message=\"Generating volcano plot\",{\n\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast, names(top))\n\t  if( is.na(ix)) return (NULL)\n\t  top1 <- top[[ix]];\n\t  }\n\t  incProgress(1/2)\n\t  if(dim(top1)[1] == 0 ) return (NULL)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t top1 <- as.data.frame(top1) # convert to data frame\n     top1 <- top1[which(!(is.na(top1$Fold)|is.na(top1$FDR)    )),] # remove NA's\n\t top1$upOrDown <- 1\n\t #write.csv(top1,\"tem.csv\")\n\t top1$upOrDown[ which(top1$FDR <=  input$limmaPval& top1$Fold  >= log2( input$limmaFC)) ]  <- 2\n\t top1$upOrDown[ which(top1$FDR <=  input$limmaPval & top1$Fold  <= -log2( input$limmaFC)) ]  <- 3\n\t plot(top1$Fold,-log10(top1$FDR),col = c(\"grey30\", \"red\",\"blue\")[top1$upOrDown],\n\t pch =16, cex = .3, xlab= \"log2 fold change\", ylab = \"- log10 (FDR)\")\n     legend(\"bottomright\",c(\"Upregulated\",\"Downregulated\"),fill = c(\"red\",\"blue\") )\n\n\t}) })\n\n  },height=450, width=500)\n\noutput$scatterPlot <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0  )   return(NULL)\n\t\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tif( is.null(input$selectContrast) ) return(NULL)\n\tif( is.null( limma()$comparisons ) ) return(NULL) # if no significant genes found\n\tif( length(limma()$topGenes) == 0 ) return(NULL)\n\tisolate({\n\twithProgress(message=\"Generating scatter plot with all genes\",{\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast, names(top))\n\t  if( is.na(ix)) return (NULL)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (NULL)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\t top1 <- as.data.frame(top1) # convert to data frame\n     top1 <- top1[which(!(is.na(top1$Fold)|is.na(top1$FDR)    )),] # remove NA's\n\t top1$upOrDown <- 1\n\t #write.csv(top1,\"tem.csv\")\n\t top1$upOrDown[ which(top1$FDR <=  input$limmaPval& top1$Fold  >= log2( input$limmaFC)) ]  <- 2\n\t top1$upOrDown[ which(top1$FDR <=  input$limmaPval & top1$Fold  <= -log2( input$limmaFC)) ]  <- 3\n\n     incProgress(1/2)\n\t if (grepl(\"Diff:\",input$selectContrast) == 1) return(NULL) # iz=1:(dim(convertedData())[2]) # if it is factor design use all samples\n  \t # average expression\n     samples = unlist(strsplit( input$selectContrast, \"-\"))\n     iz= match( detectGroups(colnames(convertedData())), samples[1]\t  )\n     iz = which(!is.na(iz))\n\t genes <- convertedData()[,iz]\n\t genes <- as.data.frame(genes)\n\t genes$average1 <- apply( genes,1,mean)\n\n     iz= match( detectGroups(colnames(convertedData())), samples[2]\t  )\n     iz = which(!is.na(iz))\n\t # genes <- cbind( genes,convertedData()[,iz] )\n\t genes$average2 <- apply(convertedData()[,iz] ,1,mean)\n\tgenes <- merge(genes,top1,by=\"row.names\")\n # write.csv(genes, \"tem.csv\")\n\tplot(genes$average2,genes$average1,col = c(\"grey45\",\"red\",\"blue\")[genes$upOrDown],\n\t pch =16, cex = .3, xlab= paste(\"Average expression in\", samples[2] ), ylab = paste(\"Average expression in\", samples[1] ))\n     legend(\"bottomright\",c(\"Upregulated\",\"Downregulated\"),fill = c(\"red\",\"blue\") )\n\n\t\t})\n\n\t})\n\n  },height=450, width=500)\n\noutput$geneListGO <- renderTable({\n\n\tif (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\tif( is.null(input$selectContrast)) return(NULL)\n\tif( is.null( input$selectGO2) ) return (NULL)\n\tif( input$selectGO2 == \"ID not recognized!\" ) return ( as.matrix(\"Gene ID not recognized.\")) #No matching species\n\n\ttem = input$selectOrg\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast; tem = input$selectGO2\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tif( is.null(limma()$results) ) return(NULL)\n\tif( is.null(selectedHeatmap.data()) ) return(NULL) # this has to be outside of isolate() !!!\n\tif(input$selectOrg == \"NEW\" && is.null( input$gmtFile) ) return(NULL) # new but without gmtFile\n\tNoSig = as.data.frame(\"No significant enrichment found.\")\n\tisolate({\n \twithProgress(message=\"GO Enrichment\", {\n\n\n\tgenes <- selectedHeatmap.data()\n\tif(is.null(genes) ) return(NULL)\n\tif(dim(genes)[1] <= minGenesEnrichment ) return(NoSig) # if has only few genes\n\n\tgroups = detectGroups(colnames(genes) )\n\tN1 = sum(groups == groups[1] ) # number of samples in type above\n\tif( dim(genes)[2] < N1) return(NoSig)\n\tfc = rowMeans(genes[,1:N1])-rowMeans(genes[,(N1+1):length(groups)])\n\n\t# GO\n\tresults1 <- NULL; result <- NULL\n\tpp <- 0\n\tfor( i in c(1,-1) ) {\n\t\tincProgress(1/2 )\n\n\t\tif( length(which(fc*i<0)) <= minGenesEnrichment) next;\n\t\tquery = rownames(genes)[which(fc*i<0)]\n\t\tif( length(query) <= minGenesEnrichment) next;\n\n\tif(input$selectOrg == \"NEW\" && !is.null( input$gmtFile) )\n\t{ result <- findOverlapGMT( query, GeneSets(),1) } else  {\n\t\tconvertedID <- converted()\n\t\tconvertedID$IDs <- query\n\t\tresult = FindOverlap (convertedID,allGeneInfo(), input$selectGO2,input$selectOrg,1) }\n\n\tif( dim(result)[2] ==1) next;   # result could be NULL\n\t\tif(i == 1) result$Genes = \"A\"  else result$Genes = \"B\"\n\t\tif (pp==0 ) { results1 <- result; pp = 1;} else  results1 = rbind(results1,result)\n\t}\n\n\tif ( pp == 0 ) return (NoSig)\n\tif ( is.null( results1) ) return (NoSig)\n\tif( dim(results1)[2] == 1 ) return(NoSig)  # Returns a data frame: \"No significant results found!\"\n\n\tresults1= results1[,c(5,1,2,4)]\n\tcolnames(results1)= c(\"List\",\"FDR\",\"Genes\",\"GO terms or pathways\")\n\tminFDR = 0.01\n\tif(min(results1$FDR) > minFDR ) results1 = as.data.frame(\"No signficant enrichment found.\") else\n\tresults1 = results1[which(results1$FDR < minFDR),]\n\n\tincProgress(1, detail = paste(\"Done\"))\n\n\tif(dim(results1)[2] != 4) return(NoSig)\n\tcolnames(results1)= c(\"Direction\",\"adj.Pval\",\"Genes\",\"Pathways\")\n\n\tresults1$adj.Pval <- sprintf(\"%-2.1e\",as.numeric(results1$adj.Pval) )\n\tresults1[,1] <- as.character(results1[,1])\n\ttem <- results1[,1]\n\tresults1[ which(tem == \"A\"),1] <- gsub(\"-\",\" > \",input$selectContrast )\n\tresults1[ which(tem == \"B\"),1] <- gsub(\"-\",\" < \",input$selectContrast )\n\tresults1[ duplicated (results1[,1] ),1 ] <- \"\"\n\n\tresults1\n\t })#progress\n\t}) #isolate\n  }, digits = 0,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n #   output$selectedHeatmap <- renderPlot({       hist(rnorm(100))    })\n\noutput$DEG.Promoter <- renderTable({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\tif( is.null(input$selectContrast)) return(NULL)\n\n\ttem = input$selectOrg; tem = input$radio.promoter\n\ttem=input$limmaPval; tem=input$limmaFC; tem = input$selectContrast; tem = input$selectGO2\n\ttem = input$CountsDEGMethod; tem = input$countsLogStart; tem = input$CountsTransform\n\ttem = input$minCounts; tem = input$lowFilter; tem=input$transform; tem = input$logStart\n\tif( is.null(limma()$results) ) return(NULL)\n\tif( is.null(selectedHeatmap.data()  ) ) return(NULL)\n\t#if( !is.data.frame(selectedHeatmap.data()  ) ) return(NULL)\n\n  isolate({\n   \twithProgress(message=\"Promoter analysis\", {\n\tgenes <- selectedHeatmap.data()\n\tif(is.null(genes)) return(NULL)\n\t# if( !is.data.frame(genes)) return (NULL)\n\t# cat(\"\\nHere\",paste(genes[1,],collapse=\" \") )\n\tif( dim(genes)[1] < minGenesEnrichment ) return (NULL) # skip if less than 5 genes total\n\tgroups = detectGroups(colnames(genes) )\n\tN1 = sum(groups == groups[1] ) # number of samples in type above\n\tfc = rowMeans(genes[,1:N1])-rowMeans(genes[,(N1+1):length(groups)])\n\n\t# GO\n\tpp <- 0; results1 <- NULL; result <- NULL\n\tfor( i in c(1, -1) ) {\n\tincProgress(1/2 )\n\tquery = rownames(genes)[which(fc*i<0)]\n\tif(length(query) < minGenesEnrichment) next;\n\tconvertedID = convertID(query,input$selectOrg, input$selectGO2 );#\"gmax_eg_gene\"\n\tif(length(convertedID) < minGenesEnrichment) next;\n\tresult <- promoter( convertedID,input$selectOrg,input$radio.promoter )\n\n\tif( is.null(result)  ) next;   # result could be NULL\n\tif(  dim(result)[2] ==1) next;\n\n\tif(i == 1) result$List =\"A\"  else result$List =\"B\"\n\tif (pp==0 ) { results1 <- result; pp <- 1 } else  { results1 = rbind(results1,result) }\n\t}\n\n\tincProgress(1, detail = paste(\"Done\"))\n\t}) #progress\n\n\tif( is.null(results1)) {as.data.frame(\"No significant motif enrichment found.\")} else {\n\tresults1 <- results1[,c(4,1:3,5)]\n\ttem <- results1[,1]\n\tresults1[ which( tem == \"A\"),1] <- gsub(\"-\",\" > \",input$selectContrast )\n\tresults1[ which( tem == \"B\"),1] <- gsub(\"-\",\" < \",input$selectContrast )\n\tresults1[ duplicated (results1[,1] ),1 ] <- \"\"\n\tresults1\n\t   }\n  })\n  }, digits = -1,spacing=\"s\",striped=TRUE,bordered = TRUE, width = \"auto\",hover=T)\n\noutput$RsessionInfo <- renderText({\n      if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\tas.character( print(sessionInfo(),locale=FALSE) )\n  })\n\n\ngenomePlotDataPre <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n\n\ttem = input$selectOrg ;\n\ttem = input$selectContrast2\n\n  isolate({\n\twithProgress(message=\"Identifying differentially expressed genomic regions using PREDA\", {\n\tif (is.null(input$selectContrast2 ) ) return(NULL)\n\n\tif( length(limma()$topGenes) == 0 ) return(NULL)\n\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast2, names(top))\n\t  if( is.na(ix)) return (NULL)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (NULL)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\n\t # write.csv(merge(top1,allGeneInfo(), by.x=\"row.names\",by.y=\"ensembl_gene_id\"  ),\"tem.csv\"  )\n\t x <- merge(top1,allGeneInfo(), by.x=\"row.names\",by.y=\"ensembl_gene_id\"  )\n\n\t #hist(top1[,1])\n\n\t ########## PREDA\n\tinfofile <- system.file(\"sampledata\", \"GeneExpression\", \"sampleinfoGE_PREDA.txt\", package = \"PREDAsampledata\")\n\tsampleinfo<-read.table(infofile, sep=\"\\t\", header=TRUE)\n\thead(sampleinfo)\n\n\tdata(gaExpressionSetRCC)\n\tGEstatisticsForPREDA<-statisticsForPREDAfromEset(gaExpressionSetRCC, statisticType=\"tstatistic\", referenceGroupLabel=\"normal\", classVector=sampleinfo[,\"Class\"])\n\tanalysesNames(GEstatisticsForPREDA)\n\n\tGEGenomicAnnotations<-GenomicAnnotationsFromLibrary(annotLibrary=\"gahgu133plus2.db\", retain.chrs=1:22, optionalAnnotations=c(\"SYMBOL\", \"ENTREZID\"))\n\tGEGenomicAnnotationsForPREDA<-GenomicAnnotations2GenomicAnnotationsForPREDA(GEGenomicAnnotations, reference_position_type=\"median\")\n\tGEDataForPREDA<-MergeStatisticAnnotations2DataForPREDA(GEstatisticsForPREDA, GEGenomicAnnotationsForPREDA, sortAndCleanNA=TRUE)\n\n\t#x = read.csv(\"PREDA_test.csv\")\n\n\t#x <- x[,-1] # remove the row index, not needed in Shiny\n\n\t x <- x[order(x$chromosome_name,x$start_position),]\n\t tem = sort( table( x$chromosome_name), decreasing=T)\n\t chromosomes <- names( tem[tem > 100 ] )  # chromosomes with less than 100 genes are excluded\n\t if(length(chromosomes) > 50) chromosomes <- chromosomes[1:50]  # at most 50 chromosomes\n\n\t chromosomes = chromosomes[order(as.numeric(chromosomes) ) ]\n\t # chromosomes = chromosomes[!is.na(as.numeric(chromosomes) ) ]\n\t chromosomesNumbers = as.numeric(chromosomes)\n\t # convert chr.x to numbers\n\t  j = max( chromosomesNumbers,na.rm=T)\n\t  for( i in 1:length( chromosomes)) {\n\t   if ( is.na(chromosomesNumbers[i]) )\n\t   { chromosomesNumbers[i] <- j+1; j <- j+1; }\n\t }\n\n\t x <- x[which(x$chromosome_name %in% chromosomes   ),]\n\t x <- droplevels(x)\n\n\t# find the number coding for chromosome\n\t getChrNumber <- function (chrName){\n\t return( chromosomesNumbers[ which( chromosomes == chrName)] )\n\t }\n\t  x$chrNum = 1 # numeric coding\n\t  x$chrNum <- unlist( lapply( x$chromosome_name, getChrNumber) )\n\n\t x$Row.names <- as.character( x$Row.names)\n\t fold = x$Fold; names(fold) = x$Row.names\n\n\t# write.csv(x,\"tem.csv\")\n\t x <- x[!duplicated(x$Row.names),]\n\t #rownames(x) = x$Row.names\n\n\t myData <- GEDataForPREDA\n\n\t myData@position <- as.integer( x$start_position+ x$genomeSpan/2 )\n\t myData@ids <- as.character( x$Row.names)\n\t myData@chr <- as.integer( x$chrNum )\n\t myData@start <- x$start_position\n\t myData@end <- x$start_position + x$genomeSpan\n\t myData@strand <- rep(1,dim(x)[1])\n\t myData@chromosomesLabels <- chromosomes\n\t myData@chromosomesNumbers <- as.integer( chromosomesNumbers )\n\t myData@statistic <- as.matrix( x[,2,drop=FALSE] )\n\t myData@analysesNames <- \"Test\"\n\t myData@testedTail <- \"both\"\n\t myData@optionalAnnotations <- as.matrix( x[,1:2,drop=FALSE] )\n\t myData@optionalAnnotationsHeaders <- c(\"a\",\"b\")\n\n\tincProgress(1/2, \"Runing 1000x permutations using PREDA. This may take up to 5 minutes.\")\n\tGEanalysisResults<-PREDA_main(myData,nperms = PREDA_Permutations)\n\n\treturn( GEanalysisResults )\n\t}) # progress\n\t}) # isloate\n  })\n\ngenomePlotData <- reactive({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    if(is.null(genomePlotDataPre() ) ) return(NULL)\n\n\ttem = input$selectOrg ;\n\ttem = input$selectContrast2\n\ttem = input$StatisticCutoff\n\ttem = input$RegionsPvalCutoff\n\n  isolate({\n\twithProgress(message=\"Identifying differentially expressed genomic regions using PREDA\", {\n\tif (is.null(input$selectContrast2 ) ) return(NULL)\n\n\tif( length(limma()$topGenes) == 0 ) return(NULL)\n\n\tif(length( limma()$comparisons)  ==1 )\n    { top1=limma()$topGenes[[1]]\n\t} else {\n\t  top = limma()$topGenes\n\t  ix = match(input$selectContrast2, names(top))\n\t  if( is.na(ix)) return (NULL)\n\t  top1 <- top[[ix]];\n\t  }\n\t  if(dim(top1)[1] == 0 ) return (NULL)\n\t  colnames(top1)= c(\"Fold\",\"FDR\")\n\n\t # write.csv(merge(top1,allGeneInfo(), by.x=\"row.names\",by.y=\"ensembl_gene_id\"  ),\"tem.csv\"  )\n\t x <- merge(top1,allGeneInfo(), by.x=\"row.names\",by.y=\"ensembl_gene_id\"  )\n\n\t x <- x[order(x$chromosome_name,x$start_position),]\n\t tem = sort( table( x$chromosome_name), decreasing=T)\n\t chromosomes <- names( tem[tem > 100 ] )  # chromosomes with less than 100 genes are excluded\n\t if(length(chromosomes) > 50) chromosomes <- chromosomes[1:50]  # at most 50 chromosomes\n\n\t chromosomes = chromosomes[order(as.numeric(chromosomes) ) ]\n\t # chromosomes = chromosomes[!is.na(as.numeric(chromosomes) ) ]\n\t chromosomesNumbers = as.numeric(chromosomes)\n\t # convert chr.x to numbers\n\t  j = max( chromosomesNumbers,na.rm=T)\n\t  for( i in 1:length( chromosomes)) {\n\t   if ( is.na(chromosomesNumbers[i]) )\n\t   { chromosomesNumbers[i] <- j+1; j <- j+1; }\n\t }\n\n\t x <- x[which(x$chromosome_name %in% chromosomes   ),]\n\t x <- droplevels(x)\n\n\t# find the number coding for chromosome\n\t getChrNumber <- function (chrName){\n\t return( chromosomesNumbers[ which( chromosomes == chrName)] )\n\t }\n\t  x$chrNum = 1 # numeric coding\n\t  x$chrNum <- unlist( lapply( x$chromosome_name, getChrNumber) )\n\n\t x$Row.names <- as.character( x$Row.names)\n\t fold = x$Fold; names(fold) = x$Row.names\n\n\t# write.csv(x,\"tem.csv\")\n\t x <- x[!duplicated(x$Row.names),]\n\t #rownames(x) = x$Row.names\n\n\tincProgress(1/2, \"Summarizing statistics\")\n\tGEanalysisResults <- genomePlotDataPre();\n\n\tgenomic_regions_UP<-PREDAResults2GenomicRegions(GEanalysisResults, qval.threshold=input$RegionsPvalCutoff, smoothStatistic.tail=\"upper\", smoothStatistic.threshold= input$StatisticCutoff)\n\tgenomic_regions_DOWN<-PREDAResults2GenomicRegions(GEanalysisResults, qval.threshold=input$RegionsPvalCutoff, smoothStatistic.tail=\"lower\", smoothStatistic.threshold= -1 *input$StatisticCutoff)\n\n\tif( is.null(genomic_regions_UP$Test) &&  is.null(genomic_regions_UP$Test)  ) return(-1) # no significant regions\n\n\tregions <- 0\n\tif( !is.null(genomic_regions_UP$Test)) {\n\tdataframe_UPregions<-GenomicRegions2dataframe(genomic_regions_UP[[1]])\n\tdataframe_UPregions$Regulation <- \"Up\"\n\tregions = dataframe_UPregions\n\t}\n\n\tif( !is.null(genomic_regions_DOWN$Test) ){\n\tdataframe_DOWNregions<-GenomicRegions2dataframe(genomic_regions_DOWN[[1]])\n\tdataframe_DOWNregions$Regulation <- \"Down\"\n\tif ( class(regions) != \"data.frame\" ) regions <- dataframe_DOWNregions else # if UP regions is NULL\n\t regions = rbind(regions,dataframe_DOWNregions  )\n\t}\n\n\tif( class(regions) != \"data.frame\") return(-1)\n\n\tRegions <- regions[,c(4,1:3)]\n\tRegions <- Regions[which(Regions$end != Regions$start),]\n\tRegions$size = round((Regions$end - Regions$start )/1000000,3)\n\tRegions$chr <- chromosomes[ Regions$chr ] # convert from chr. number to names\n\n\t# find the gene indices in the up or down regulated regions\n\tregulatedGenes <- function (i) {\n\tix =  which( Regions$chr == x$chromosome_name[i] &\n\t\t Regions$start < x$start_position[i] #&(Regions$end > x$start_position[i] + x$genomeSpan[i])\n\t\t &(Regions$end > x$start_position[i] )) # if the start position is within the region\n\tif( length(ix) == 0 | length(ix) >1  ) return(NA) else return( ix )\n\t}\n\n\tregionID = unlist( lapply(1:dim(x)[1], regulatedGenes) )\n\tx1 = x[which(!is.na(regionID)),]\n\tregionID = regionID[!is.na(regionID)]\n\tx1 = cbind(regionID,Regions[regionID, ], x1[,c('symbol', 'Row.names', 'Fold','FDR', 'band','start_position')])\n\tx1 = x1[order(x1$regionID,x1$start_position ), ]\n    colnames(x1)[8] = \"Ensembl\"; colnames(x1)[4] = \"Region.Start\";colnames(x1)[5] = \"Region.End\"; colnames(x1)[12] = \"Gene.Start\"\n\n\t# number of genes\n\ttem = table(x1$regionID)\n\tRegions$Ngenes = 0\n\tRegions$Ngenes[as.integer(names(tem) ) ] <- tem\n\n\t# cytoband per region\n\ttem = unique(x1[,c('regionID','band')])\n\ttem$band = gsub(\"\\\\..*\",\"\",tem$band)\n\ttem = unique(tem)\n\tRegions$band =\"\"\n\tRegions$ID <- 1:dim(Regions)[1]\n\tfor ( i in 1:dim(Regions)[1] )\n\t  Regions$band[i] <- paste( tem[ which( tem[,1] == Regions$ID[i]),2],  collapse=\";\" )\n\n\t# Genes\n\tRegions$Genes <- \"\"\n\tfor ( i in 1:dim(Regions)[1] )\n\t  Regions$Genes[i] <- paste( x1$symbol[ which( x1[,1] == Regions$ID[i])],  collapse=\" \" )\n\treturn( list(mainResult = GEanalysisResults, Regions = Regions, Genes = x1,legend.x=max(x$start_position)*.6, legend.y=max(chromosomesNumbers)-3  ) )\n\t}) # progress\n\t}) # isloate\n  })\n\n\noutput$genomePlot <- renderPlot({\n    if (is.null(input$file1)&& input$goButton == 0)   return(NULL)\n    if( is.null( genomePlotData() ) ) return(NULL)\n\ttem = input$selectOrg ;\n\ttem = input$selectContrast2\n\ttem = input$StatisticCutoff\n\ttem = input$RegionsPvalCutoff\n\nisolate({\n  if( class(genomePlotData()) != \"list\" ) { plot.new(); text(0.2,1, \"No significant regions found!\")} else {\n   GEanalysisResults <- genomePlotData()$mainResult;\n     if( is.null( GEanalysisResults ) ) return(NULL)\n\tgenomic_regions_UP<-PREDAResults2GenomicRegions(GEanalysisResults, qval.threshold=input$RegionsPvalCutoff, smoothStatistic.tail=\"upper\", smoothStatistic.threshold= -1 *input$StatisticCutoff)\n\tgenomic_regions_DOWN<-PREDAResults2GenomicRegions(GEanalysisResults, qval.threshold=input$RegionsPvalCutoff, smoothStatistic.tail=\"lower\", smoothStatistic.threshold= -1 *input$StatisticCutoff)\n\n\tcheckplot<-genomePlot(GEanalysisResults, genomicRegions=c(genomic_regions_UP, genomic_regions_DOWN), grouping=c(1, 1), scale.positions=\"Mb\", region.colors=c(\"red\",\"blue\"))\n\tlegend(x=genomePlotData()$legend.x, y=genomePlotData()$legend.y , legend=c(\"UP\", \"DOWN\"), fill=c(\"red\",\"blue\"))\n\t} #if  else\n \t })\n  }, height = 1000, width = 1000)\n\noutput$downloadRegions <- downloadHandler(\n     filename = function() {paste(\"Diff_Chr_Regions_\",input$selectContrast2,\".csv\",sep=\"\")},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(genomePlotData()$Regions, file, row.names=FALSE)\n\t    }\n  )\noutput$downloadGenesInRegions <- downloadHandler(\n     filename = function() {paste(\"Genes_in_Diff_Chr_Regions_\",input$selectContrast2,\".csv\",sep=\"\")},\n\t\tcontent = function(file) {\n\t\t\twrite.csv(genomePlotData()$Genes, file, row.names=FALSE)\n\t    }\n  )\noutput$chrRegionsList <- renderTable({\n  if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n\n  tem = input$selectContrast2\n  if( is.null( genomePlotData() ) |class(genomePlotData()) != \"list\"   ) return(NULL)\n      tem = genomePlotData()$Regions\n\t  tem = tem[,c(8,1:7,9)]\n\t  colnames(tem)[1] =\"RegionID\"\n\t  tem = tem[,-7]\n\n\t  tem <- tem[,c(2,3,6,7)]\n\t  colnames(tem) = c(\"Dir.\",\"Chr\",\"Mbp\",\"Band\")\n\t  tem$Mbp <- round(tem$Mbp,2)\n\t  tem\n\n  },rownames= FALSE)\noutput$chrRegions <- DT::renderDataTable({\n  if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n  tem = input$selectContrast2\n      tem = genomePlotData()$Regions\n\t  tem = tem[,c(8,1:7,9)]\n\t  colnames(tem)[1] =\"RegionID\"\n\t  tem = tem[,-7]\n\n\t  tem\n\n  },rownames= FALSE)\noutput$genesInChrRegions <- DT::renderDataTable({\n  if (is.null(input$file1) && input$goButton == 0)   return(NULL)\n  tem = input$selectContrast2\n\n      tem = genomePlotData()$Genes\n\t   tem <- tem[,-c(5,10,12)]\n\t  tem$Fold <- round(tem$Fold,3)\n\t  colnames(tem)[2]=\"Dir\"\n\t  tem\n\n\n  },rownames= FALSE)\n\n})  # shiny Server\n",
    "created" : 1494273680926.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "68|32|85|0|\n201|29|206|0|\n208|31|216|0|\n219|35|242|0|\n245|82|281|0|\n283|26|287|1|\n454|51|520|0|\n557|43|582|1|\n585|64|654|0|\n657|71|676|2|\n679|71|708|0|\n711|76|751|0|\n935|67|1003|0|\n",
    "hash" : "76963158",
    "id" : "D0336479",
    "lastKnownWriteTime" : 1494359872,
    "last_content_update" : 1494360718922,
    "path" : "~/Desktop/idep/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}